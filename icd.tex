%!TEX TS-program = pdflatexmk
\documentclass[cleanfoot]{asme2ej}
\usepackage[]{graphicx}
\graphicspath{ {images/} }

\usepackage{enumitem}
\usepackage{amsmath,amssymb}
\usepackage{textcomp}
\usepackage[urlcolor=blue,linkcolor=red,colorlinks=true]{hyperref}
\usepackage[autostyle, english=american]{csquotes}
\MakeOuterQuote{"}

\title{Exoplanet Open-Source Imaging Mission Simulator (EXOSIMS) \\ Interface Control Document}

%%% first author
\author{Dean Keithly, Corey Spohn, Christian Delacroix, Daniel Garrett, and Dmitry Savransky
    \affiliation{
    Sibley School of Mechanical and Aerospace Engineering\\
	Cornell University\\
	Ithaca, NY 14853
    }	
}

\def\mf{\mathbf}
\def\mb{\mathbb}
\def\mc{\mathcal}
\newcommand{\R}{\mathbf{r}}
\newcommand{\bc}{\mathbf{b}}
\newcommand{\mfbar}[1]{\mf{\bar{#1}}}
\newcommand{\mfhat}[1]{\mf{\hat{#1}}}
\newcommand{\bmu}{\boldsymbol{\mu}}
\newcommand{\blam}{\boldsymbol{\Lambda}}
\newcommand{\refeq}[1]{Equation  (\ref{#1})} 
\newcommand{\reftable}[1]{Table \ref{#1}} 
\newcommand{\refch}[1]{Chapter  \ref{#1}} 
\newcommand{\reffig}[1]{Figure \ref{#1}}
\newcommand{\refcode}[1]{Listing \ref{#1}}
\newcommand{\intd}[1]{\ensuremath{\,\mathrm{d}#1}}
\newcommand{\leftexp}[2]{{\vphantom{#2}}^{#1}\!{#2}}
\newcommand{\leftsub}[2]{{\vphantom{#2}}_{#1}\!{#2}}
\newcommand{\fddt}[1]{\ensuremath{\leftexp{\mathcal{#1}}{\frac{\mathrm{d}}{\mathrm{d}t}}}}
\newcommand{\fdddt}[1]{\ensuremath{\leftexp{\mathcal{#1}}{\frac{\mathrm{d}^2}{\mathrm{d}t^2}}}}
\newcommand{\omegarot}[2]{\ensuremath{\leftexp{\mathcal{#1}}{\boldsymbol{\omega}}^{\mathcal{#2}}}}


\begin{document}

\maketitle    

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
{\it This document describes the extensible, modular, open source software framework EXOSIMS.  EXOSIMS creates end-to-end simulations of space-based exoplanet imaging missions using stand-alone software modules.  The input/output interfaces of each module and interactions of modules with each other are presented to give guidance on mission specific modifications to the EXOSIMS framework. Last Update: \today}
\end{abstract}

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{nomenclature}
\entry{EXOSIMS}{Exoplanet Open-Source Imaging Mission Simulator}
\entry{ICD}{Interface Control Document}
\entry{MJD}{Modified Julian Day}
\end{nomenclature}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCTION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction} 
Building confidence in a mission concept's ability to achieve its science goals is always desirable.  Unfortunately, accurately modeling the science yield of an exoplanet imager can be almost as complicated as designing the mission.  It is challenging to compare science simulation results and systematically test the effects of changing one aspect of the instrument or mission design.

EXOSIMS (Exoplanet Open-Source Imaging Mission Simulator) addresses this problem by generating ensembles of mission simulations for exoplanet direct imaging missions to estimate science yields. It is designed to allow systematic exploration of exoplanet imaging mission science yields.  It consists of stand-alone modules written in Python which may be modified without requiring modifications to other portions of the code. This allows EXOSIMS to be easily used to investigate new designs for instruments, observatories, or overall mission designs independently. This document describes the required input/output interfaces for the stand-alone modules to enable this flexibility.

\subsection{Purpose and Scope} % Rework this section
This Interface Control Document (ICD) provides an overview of the software framework of EXOSIMS and some details on its component parts.  As the software is intended to be highly reconfigurable, operational aspects of the code are emphasized over implementational details.  Specific examples are taken from the coronagraphic instrument under development for WFIRST.  The data inputs and outputs of each module are described. Following these guidelines will allow the code to be updated to accommodate new mission designs.

This ICD defines the input/output of each module and the interfaces between modules of the code.  This document is intended to guide mission planners and instrument designers in the development of specific modules for new mission designs.

%\subsection{Glossary}
%This section will contain definition of terms used throughout the document if needed.

\section{Overview}
The terminology used to describe the software implementation is loosely based upon object-oriented programing (OOP) terminology, as implemented by the Python language, in which EXOSIMS is built.  The term module can refer to the object class prototype representing the abstracted functionality of one piece of the software, an implementation of this object class which inherits the attributes and methods of the prototype, or an instance of this class.  Input/output definitions of modules refer to the class prototype.  Implemented modules refer to the inherited class definition.  Passing modules (or their outputs) means the instantiation of the inherited object class being used in a given simulation.  Relying on strict inheritance for all implemented module classes provides an automated error and consistency-checking mechanism.  The outputs of a given object instance may be compared to the outputs of the prototype.  It is trivial to pre-check whether a given module implementation will work within the larger framework, and this approach allows for flexibility and adaptability.

% \begin{figure}[ht]
%     \begin{center}
%         \begin{tabular}{c}
%              \includegraphics[width=0.9\textwidth]{codeflow5}
%         \end{tabular}
%     \end{center}
%     \caption{EXOSIMS modules. Each box represents a component software module that interacts with other modules as indicated by the arrows. The simulation modules pass all input modules along with their own output.  Thus, the Survey Ensemble module has access to all of the input modules and all of the upstream simulation modules.}
%     \label{figure_framework}
% \end{figure}

\begin{figure}[ht]
    \begin{center}
        \begin{tabular}{c}
             \includegraphics[width=0.95\textwidth]{instantiation_tree2b}
        \end{tabular}
    \end{center}
    \caption{Schematic depiction of the instantiation path of all EXOSIMS modules.  The arrows indicate calls to the object constructor, and object references to each module are always passed up directly to the top calling module, so that a given module has access to any other module connected to it by a direct path of instantiations. For example, the TargetList module has access to both the PostProcessing and BackgroundSources modules, while the Observatory module does not have access to any other modules. The typical entry point to EXOSIMS is the  construction of a MissionSim object, which causes the instantiation of the SurveySimulation module, which in turn instnatiates all the other modules. In the case of a parallelize SurveyEnsemble instnatiation, multiple, independent SurveySimulation modules are instantiated at the same time.  At the end of construction, the MissionSim and SurveySimulation objects have direct access to all other modules as their attributes.}
    \label{fig:instantiation_tree}
\end{figure}

The overall framework of EXOSIMS is depicted in \reffig{fig:instantiation_tree}, which shows all of the component software modules in the order in which they are instantiated in normal operation. Standard EXOSIMS modules are:
\begin{itemize}
    \item Optical System
    \item Star Catalog
    \item Planet Population
    \item Observatory
    \item Planet Physical Model
    \item Time Keeping
    \item Zodiacal Light
    \item Background Sources
    \item Post-Processing 
    \item Target List
    \item Simulated Universe
    \item Survey Simulation
    \item Survey Ensemble
\end{itemize}  

Objects of all module classes can be instantiated independently, although most modules require the instantiation of other modules during their construction (see \reffig{fig:instantiation_tree}). Different implementations of the modules contain specific mission design parameters and physical descriptions of the universe, and will change according to mission and planet population of interest.  The upstream modules (including Target List, Simulated Universe, Survey Simulation, and Survey Ensemble modules) take information contained in the downstream modules and perform mission simulation tasks. The instantiation of an object of any of these modules requires the instantiation of one or more downstream module objects.  Any module may perform any number or kind of calculations using any or all of the input parameters provided.  The specific implementations are only constrained by their input and output specification contained in this document.


\begin{figure}[ht]
    \begin{center}
        \begin{tabular}{c}
             \includegraphics[width=0.75\textwidth]{starcatalog_flowdown}
        \end{tabular}
    \end{center}
    \caption{Schematic of a sample implementation for the three module layers for the Star Catalog module. The Star Catalog prototype (top row) is immutable, specifies the input/output structure of the module along with all common functionality, and is inherited by all Star Catalog class implementations (middle row).  In this case, two different catalog classes are shown: one that reads in data from a SIMBAD catalog dump, and one which contains only information about a subset of known radial velocity targets.  The object used in the simulation (bottom row) is an instance of one of these classes, and can be used in exactly the same way in the rest of the code due to the common input/output scheme.}
    \label{fig:starcatalog_flowdown}
\end{figure}

\begin{figure}[ht]
    \begin{center}
        \begin{tabular}{c}
             \includegraphics[width=0.75\textwidth]{observatory_flowdown}
        \end{tabular}
    \end{center}
    \caption{Schematic of a sample implementation for the three module layers for the Observatory module. The Observatory prototype (top row) is immutable, specifies the input/output structure of the module along with all common functionality, and is inherited by all Observatory class implementations (middle row).  In this case, two different observatory classes are shown that differ only in the definition of the observatory orbit.  Therefore, the second implementation inherits the first (rather than directly inheriting the prototype) and overloads only the orbit method. The object used in the simulation (bottom row) is an instance of one of these classes, and can be used in exactly the same way in the rest of the code due to the common input/output scheme.}
    \label{fig:observatory_flowdown}
\end{figure}

Figures \ref{fig:starcatalog_flowdown} and \ref{fig:observatory_flowdown} show schematic representations of the three different aspects of a module, using the Star Catalog and Observatory modules as examples, respectively.  Every module has a specific prototype that sets the input/output structure of the module and encodes any common functionality for all module class implementations.  The various implementations inherit the prototype and add/overload any attributes and methods required for their particular tasks, limited only by the preset input/output scheme.  Finally, in the course of running a simulation, an object is generated for each module class selected for that simulation.  The generated objects can be used in exactly the same way in the downstream code, regardless of what implementation they are instances of, due to the strict interface defined in the class prototypes.

For lower level (downstream) modules, the input specification is much more loosely defined than the output specification, as different implementations may draw data from a wide variety of sources.  For example, the star catalog may be implemented as reading values from a static file on disk, or may represent an active connection to a local or remote database.  The output specification for these modules, however, as well as both the input and output for the upstream modules, is entirely fixed so as to allow for generic use of all module objects in the simulation.


\section{Global Specifications}
Common references (units, frames of reference, etc.) are required to ensure interoperability between the modules of EXOSIM.  All of the references listed below must be followed.

\begin{description}
    \item[Common Epoch] \hfill \\ J2000
    \item[Common Reference Frame] \hfill \\ Heliocentric Equatorial (HE)
\end{description}

\subsection{Python Packages} 
EXOSIMS is an open source platform.  As such, packages and modules may be imported and used for calculations within any of the stand-alone modules.  The following commonly used Python packages are used for the WFIRST-specific implementation of EXOSIMS:

\texttt{
\begin{itemize}
    \item astropy
        \begin{itemize}
            \item astropy.constants
            \item astropy.coordinates
            \item astropy.time
            \item astropy.units
        \end{itemize}
    \item copy
    \item hashlib
    \item importlib
    \item numpy
        \begin{itemize}
            \item numpy.linalg 
        \end{itemize}
    \item os
        \begin{itemize}
            \item os.path 
        \end{itemize}
    \item pickle/cPickle
    \item scipy
        \begin{itemize}
            \item scipy.io
            \item scipy.special
            \item scipy.interpolate
        \end{itemize}
    \item sys
    \item logging
    \item time
    \item json
    \item random
    \item re
    \item inspect
    \item subprocess
    \item csv
    \item h5py (\emph{optional})
    \item jplephem (\emph{optional})
\end{itemize}
}

Additionally, while not required for running the survey simulation, \verb+matplotlib+ is used for visualization of the results.

\subsection{Coding Conventions}
In order to allow for flexibility in using alternate or user-generated module implementations, the only requirement on any module is that it inherits (either directly or by inheriting another module implementation that inherits the prototype) the appropriate prototype.  It is similarly expected that the prototype constructor will be called from the constructor of the newly implemented class.  An example of an Optical System module implementation follows:

\begin{verbatim}
from EXOSIMS.Prototypes.OpticalSystem import OpticalSystem

class ExampleOpticalSystem(OpticalSystem):
    
    def __init__(self, **specs):
                
        OpticalSystem.__init__(self, **specs)
        
        ...

\end{verbatim}

\emph{Note that the filename must match the class name for all modules.}

\subsubsection{Module Type}
It is always possible to check whether a module is an instance of a given prototype, for example:
\begin{verbatim}
isinstance(obj,EXOSIMS.Prototypes.Observatory.Observatory)
\end{verbatim}
However, it can be tedious to look up all of a given object's base classes so, for convenience, every prototype will provide a private variable \verb+_modtype+, which will always return the name of the prototype and should not be overwritten by any module code.  Thus, if the above example evaluates as \verb+True+, \verb+obj._modtype+ will return \verb+Observatory+.

\subsubsection{Callable Attributes}
Certain module attributes must be represented in a way that allows them to be parametrized by other values.  For example, the instrument throughput and contrast are functions of both the wavelength and the angular separation, and so must be encodable as such in the optical system module.  To accommodate this, as well as simpler descriptions where these parameters may be treated as static values, these and other attributes are defined as `callable'.  This means that they must be set as objects that can be called in the normal Python fashion, i.e., \verb+object(arg1,arg2,...)+.  

These objects can be function definitions defined in the code, or imported from other modules.  They can be \href{https://docs.python.org/2/reference/expressions.html#lambda}{lambda expressions} defined inline in the code.  Or they can be callable object instances, such as the various \href{http://docs.scipy.org/doc/scipy/reference/interpolate.html}{scipy interpolants}.  In cases where the description is just a single value, these attributes can be defined as dummy functions that always return the same value, for example:
\begin{verbatim}
def throughput(wavelength,angle):
     return 0.5
\end{verbatim}
or even more simply:
\begin{verbatim}
throughput = lambda wavelength,angle: 0.5
\end{verbatim}

\emph{Note, however, that Python differentiates between how it treats class attributes and methods in inheritance. If a value is originally defined as an attribute (such as a lambda function), then it cannot be overloaded by a method in an inheriting class implementation.  So, if a prototype contains a callable value as an attribute, it must be implemented as an attribute in all inheriting implementations that wish to change the value.  For this reason, the majority of callable attributes in prototype modules are instead defined as methods to avoid potential overloading issues.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BACKBONE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Survey Simulation (Backbone)}
By default, the simulation execution will be performed via the SurveySimulation module.  This will consist of a limited set of functions that will primarily be tasked with parsing the input specification described below, and then creating the specified instances of each of the framework modules, detailed in \S\ref{sec:modules}.  For convenience, there is a higher-level \mbox{MissionSim} class, whose constructor will take the input script file (\S\ref{sec:inputspec}) and generate instances of all module objects, including the SurveySimulation (\S\ref{sec:surveysim}) and SurveyEnsemble modules, which will contain the functions to run the survey simulations. However, for mission ensembles, the base object created on all workers is SurveySimulation, so that a MissionSim object will exist only on the controller node of the cluster.  Any mission-specific execution variations will be introduced by method overloading in the inherited SurveySimulation implementation. \reffig{fig:instantiation_tree} provides a graphical description of the instantiation order of all module objects.


A simulation specification is a single JSON-formatted (\url{http://json.org/}) file that encodes user-settable parameters and module names.  SurveySimulation will contain a reference specification with \emph{all} parameters and modules set via defaults in the constructors of each of the modules.  In the initial parsing of the user-supplied specification, it will be merged with the reference specification such that any fields not set by the user will be assigned to their reference (default) values.   Each instantiated module object will contain a dictionary called \verb+_outspec+, which, taken together, will form the full specification for the current run (as defined by the loaded modules).  This specification will be written out to a json file associated with the output of every run.  \emph{Any specification added by a user implementation of any module must also be added to the \_outspec dictionary}.  The assembly of the full output specification is provided by MissionSim method \verb+genOutSpec+.

%The backbone will also contain a specification parser that will check specification files for internal consistency.  For example, if modules carry mutual dependencies, the specification parser will return an error if these are not met for a given specification.  Similarly, if modules are selected with optional top level inputs, warnings will be generated if these are not set in the same specification files.
%In addition to the specification parser, the backbone will contain a method for comparing two specification files and returning the difference between them.  Assuming that the files specify all user-settable values, this will be equivalent to simply performing a \verb+diff+ operation on any POSIX system.  The backbone diff function will add in the capability to automatically fill in unset values with their defaults.  

For every simulation (or ensemble), an output specification will be written to disk along with the simulation results with all defaults used filled in.

%The backbone will also contain an interactive function to help users generate specification files via a series of questions. 

\subsection{Specification Format}\label{sec:inputspec}
The JSON specification file will contain a series of objects with members enumerating various user-settable parameters, top-level members for universal settings (such as the mission lifetime) and arrays of objects for multiple related specifications, such as starlight suppression systems and science instruments.  The specification file must contain a \verb+modules+ dictionary listing the module names (or paths on disk to user-implemented classes) for all modules.

\begin{verbatim}
{
    "koAngles_SolarPanel":[56.0,124.0],
    "FAP": 3e-07,
    "FAdMag0": 15,
    "IWA": 0.15,
    "Irange": [
        0.0,
        180.0
    ],
    "MDP": 0.001,
    "Mprange": [
        1.0,
        4131.0
    ],
    "OWA": 0.557002,
    "Orange": [
        0.0,
        360.0
    ],
    "Rprange": [
        1.0,
        22.6
    ],
    "WA0": 0.289498,
    "WAint": 0.3,
    "arange": [
        0.1,
        100.0
    ],
    "cachedir": "path/to/desired/cache/directory",
    "charMargin": 0.15,
    "checkKeepoutEnd": true,
    "coMass": 5800.0,
    "constrainOrbits": false,
    "dMag0": 22.5,
    "dMagLim": 22.5,
    "dMagint": 22.5,
    "erange": [
        0.01,
        0.99
    ],
    "esigma": 0.25,
    "forceStaticEphem": false,
    "havejplephem": true,
    "intCutoff": 15.0,
    "keepStarCatalog": false,
    "koAngleMax": 90.0,
    "koAngleMin": 45.0,
    "koAngleMinEarth": 45.0,
    "koAngleMinMoon": 45.0,
    "koAngleSmall": 1.0,
    "magEZ": 22.0,
    "magZ": 23.0,
    "minComp": 0.0,
    "missionLife": 5.0,
    "missionPortion": 0.0493150685,
    "missionStart": 60634.0,
    "OBduration": 14,
    "missionSchedule": sampleOB1.csv,
    "modules": {
        "BackgroundSources": "BackgroundSources",
        "Completeness": "GarrettCompleteness",
        "Observatory": "WFIRSTObservatoryL2",
        "OpticalSystem": "Nemati",
        "PlanetPhysicalModel": "Forecaster",
        "PlanetPopulation": "KeplerLike2",
        "PostProcessing": "PostProcessing",
        "SimulatedUniverse": "KeplerLikeUniverse",
        "StarCatalog": "EXOCAT1",
        "SurveyEnsemble": "SurveyEnsemble",
        "SurveySimulation": "SurveySimulation",
        "TargetList": "TargetList",
        "TimeKeeping": "TimeKeeping",
        "ZodiacalLight": "Stark"
    },
    "nVisitsMax": 5,
    "ntFlux": 1,
    "obscurFac": 0.1724,
    "observingModes": [
        {
            "SNR": 5,
            "detectionMode": true,
            "instName": "imager",
            "radDos": 0.5,
            "systName": "HLC-565"
        },
        {
            "SNR": 10,
            "instName": "spectro",
            "lam": 660,
            "radDos": 1.0,
            "systName": "SPC-660"
        }
    ],
    "occulterSep": 55000.0,
    "ppFact": 0.1,
    "prange": [
        0.083,
        0.882
    ],
    "pupilDiam": 2.37,
    "ref_Time": 0.2,
    "ref_dMag": 3.0,
    "scaleOrbits": false,
    "scienceInstruments": [
        {
            "CIC": 0.01,
            "ENF": 1.0,
            "FoV": 9.5,
            "PCeff": 0.8,
            "QE": "$HOME/Data/QEfile.fits",
            "Rs": 1.0,
            "fnumber": 60.97706197560175,
            "focal": 144.51563688217615,
            "idark": 0.000114,
            "lenslSamp": 1.0,
            "name": "imager",
            "optics": 0.518018590965876,
            "pixelNumber": 1024,
            "pixelScale": 0.0185546875,
            "pixelSize": 1.3e-05,
            "sread": 0.0,
            "texp": 100.0
        },
        {
            "CIC": 0.01,
            "ENF": 1.0,
            "FoV": 1.0,
            "PCeff": 0.8,
            "QE": "$HOME/Data/QEfile.fits",
            "Rs": 50.0,
            "fnumber": 575.4526999602537,
            "focal": 1363.8228989058011,
            "idark": 0.000114,
            "lenslSamp": 2.0,
            "name": "spectro",
            "optics": 0.465846901959329,
            "pixelNumber": 76,
            "pixelScale": 0.02631578947368421,
            "pixelSize": 0.000174,
            "sread": 0.0,
            "texp": 100.0
        }
    ],
    "settlingTime": 0.5,
    "shapeFac": 0.7853981633974483,
    "smaknee": 30.0,
    "starlightSuppressionSystems": [
        {
            "BW": 0.1,
            "IWA": 0.15,
            "OWA": 0.428996,
            "core_area": "$HOME/Data/area.fits",
            "core_contrast": 1e-10,
            "core_mean_intensity": "$HOME/Data/mean_intensity.fits",
            "core_platescale": 0.3,
            "core_thruput": "$HOME/Data/thruput.fits",
            "deltaLam": 56.5,
            "lam": 565.0,
            "name": "HLC-565",
            "occ_trans": "$HOME/Data/occ_trans.fits",
            "occulter": false,
            "ohTime": 0.5,
            "optics": 0.983647,
            "samp": 10.0,
            "koAngles_Sun":[45.0,180.0],
            "koAngles_Earth":[45.0,180.0],
            "koAngles_Moon":[45.0,180.0],
            "koAngles_Small":[1.0,180.0]
        },
        {
            "BW": 0.18,
            "IWA": 0.208876,
            "OWA": 0.557002,
            "core_area": "$HOME/Data/area.fits",
            "core_contrast": 1e-10,
            "core_mean_intensity": "$HOME/Data/mean_intensity.fits",
            "core_platescale": 0.3,
            "core_thruput": "$HOME/Data/thruput.fits",
            "deltaLam": 118.8,
            "lam": 660.0,
            "name": "SPC-660",
            "occ_trans": "$HOME/Data/occ_trans.fits",
            "occulter": false,
            "ohTime": 0.5,
            "optics": 0.9154706,
            "samp": 10.0
        }
    ],
    "staticStars": true,
    "waitMultiple": 2.0,
    "waitTime": 1.0,
    "wrange": [
        0.0,
        360.0
    ]
}
\end{verbatim}

\subsection{Modules Specification}
The final array in the input specification  (\verb+modules+) is a list of all the modules that define a particular simulation.  This is the only part of the specification that will not be filled in by default if a value is missing - each module must be explicitly specified. The order of the modules in the list is arbitrary, so long as they are all present. 

If the module implementations are in the appropriate subfolder in the EXOSIMS tree, then they can be specified by the module name.  However, if you wish to use an implemented module outside of the EXOSIMS directory, then you need to specify it via its full path in the input specification.

\emph{All modules, regardless of where they are stored on disk must inherit the appropriate prototype.}

\subsubsection{Different Planet Population and Completeness Distributions}
EXOSIMS allows for the calculation of completeness using a different planet population from the one used to populate the SimulatedUniverse. This functionality is intended to simulate the effects of our current lack of knowledge of the `true' planet population. The functionality is enabled by adding an optional \verb+completeness_specs+ dictionary to the JSON script. Below is a simple example where the Completeness is based off KeplerLike2 and Planet Population is based off JupiterTwin.

\begin{verbatim}
{
  "completeness_specs":{
    "eta":1,
    "modules":{
      "PlanetPopulation": "JupiterTwin",
      "PlanetPhyiscalModel":" "
  },
...
  "modules": {
    "PlanetPopulation": "KeplerLike2",
    "StarCatalog": "EXOCAT1",
    "OpticalSystem": "Nemati",
    "ZodiacalLight": "Stark",
    "BackgroundSources": " ",
    "PlanetPhysicalModel": "Forecaster",
    "Observatory": "WFIRSTObservatoryL2",
    "TimeKeeping": " ",
    "PostProcessing": " ",
    "Completeness": "BrownCompleteness",
    "TargetList": " ",
    "SimulatedUniverse": "KeplerLikeUniverse",
    "SurveySimulation": "SLSQPScheduler",
    "SurveyEnsemble": " "
  }
}
\end{verbatim}

In this example, the SimulatedUniverse will be populated using the KeplerLike2 PlanetPopulation with the Forecaster PhysicalModel, while the completeness will be calculated based on the JupiterTwin PlanetPopulation and the Prototype PhyscialModel.  Note also that the JupiterTwin PlanetPopulation will be passed a constructor inpu of \verb+eta=1+, whereas the KeplerLike2 constructor would not get this input, unless it was separately defined elsewhere in the JSON script.  In the case where the \verb+completeness_specs+ dictionary is ommited, all calcluations would be based on the same PlanetPopulation instance, as specified in the primary modules dictionary.


\subsection{Universal Parameters}
These parameters apply to all simulations. These parameters define the scope of values passable for module initialization. These parameters are described in detail in their specific module definitions.

\begin{itemize}[leftmargin=1.5in,font={\ttfamily}]

\item[\textbf{MissionSim}]
\item[scriptfile] (string) name of the scriptfile to load json script parameters from.
\item[nopar] (boolean) If True, ignore any provided ensemble module in the script or specs and force the prototype ensemble.
\item[verbose] (boolean) Boolean used to create the vprint function, equivalent to the python print function with an extra verbose toggle parameter (True by default). The vprint function can be accessed by all modules from EXOSIMS.util.vprint.

\item[\textbf{PlanetPopulation}]
\item[arange] (float) 1$\times$2 list of semi-major axis range in units of $ AU $. 
\item[erange] (float) 1$\times$2 list of eccentricity range.
\item[Irange] (float) 1$\times$2 list of inclination range in units of $ deg $.  
\item[Orange] (float) 1$\times$2 list of ascension of the ascending node range in units of $ deg $.  
\item[wrange] (float) 1$\times$2 list of argument of periastron range in units of $ deg $. 
\item[prange] (float) 1$\times$2 list of planetary geometric albedo range.  
\item[Rprange] (float) 1$\times$2 list of planetary radius range in Earth radii.  
\item[Mprange] (float) 1$\times$2 list of planetary mass range in Earth masses.  
\item [scaleOrbits] (boolean) True means planetary orbits are scaled by the square root of stellar luminosity. 
\item[constrainOrbits] (boolean) True means planetary orbits are constrained to never leave the semi-major axis range (arange).
\item[eta] (float) The average occurrence rate of planets per star for the entire population.

\item[\textbf{PlanetPhysicalModel}]
\item[whichPlanetPhaseFunction] (string) indicates which planet phase function to use

\item[\textbf{OpticalSystem}]
\item[obscurFac] (float) Obscuration factor due to secondary mirror and spiders.
\item[shapeFac] (float)  Telescope aperture shape factor.
\item[pupilDiam] (float) Entrance pupil diameter in units of $m$.
\item[intCutoff] (float)  Maximum allowed integration time in units of $ day $.
\item[dMag0] (float) Favorable planet delta magnitude value used to calculate the minimum integration times for inclusion in target list.
\item[WA0] (float) Instrument working angle value used to calculate the minimum integration times for inclusion in target list, in units of $arcsec$.
\item[scienceInstruments] (list of dicts) Contains specific attributes of all science instruments. 
\item[QE] (float, callable) Detector quantum efficiency: either a scalar for constant QE, or a two-column array for wavelength-dependent QE, where the first column contains the wavelengths in units of nm. May be data or FITS filename.
\item[optics] (float) Attenuation due to optics specific to the science instrument.
\item[FoV] (float) Field of view in units of arcsec
\item[pixelNumber] (integer) Detector array format, number of pixels per detector lines/columns
\item[pixelSize] (float) Detector pixel scale in units of arcsec per pixel
\item[sread] (float) Detector effective read noise per frame per pixel
\item[idark] (float) Detector dark-current per pixel in units of 1/s
\item[CIC] (float) Clock-induced-charge per frame per pixel
\item[texp] (float) Exposure time per frame in units of s
\item[radDos] (float) Radiation dosage
\item[PCeff] (float) Photon counting efficiency
\item[ENF] (float) (Specific to EM-CCDs) Excess noise factor
\item[Rs] (float) (Specific to spectrometers) Spectral resolving power
\item[lenslSamp] (float) (Specific to spectrometers) Lenslet sampling, number of pixel per lenslet rows or cols
\item[starlightSuppressionSystems] (list of dicts) All starlight suppression system attributes (variable)
\item[lam] (integer) Central wavelength in units of nm
\item[BW] (float) Bandwidth fraction
\item[occ\_trans] (float, callable) Intensity transmission of extended background sources such as zodiacal light. Includes pupil mask, occulter, Lyot stop and polarizer.
\item[core\_thruput] (float, callable) System throughput in the FWHM region of the planet PSF core.
\item[core\_contrast] (float, callable) System contrast = mean\_intensity / PSF\_peak
\item[core\_platescale] (float) Platescale used for a specific set of coronagraph parameters, in units of lambda/D per pixel
\item[PSF] (float, callable) Point spread function - 2D ndarray of values, normalized to 1 at the core. Note: normalization means that all throughput effects must be contained in the throughput attribute.
\item[ohTime] (float) Overhead time in units of days
\item[observingModes] (list of dicts) Mission observing modes attributes
\item[SNR] (integer) Signal-to-noise ratio threshold
\item[timeMultiplier] (integer) Integration time multiplier
\item[IWA] (float) Fundamental Inner Working Angle in units of $ arcsec $. No planets can ever be observed at smaller separations.
\item[OWA] (float) Fundamental Outer Working Angle in units of $ arcsec $. Set to $ Inf $ for no OWA. JSON values of 0 will be interpreted as $ Inf $.
\item[ref\_dMag] (float) reference star dMag for RDI
\item[ref\_Time] (float) fraction of time spent on ref star for RDI

\item[\textbf{ZodiacalLight}]
\item[magZ] (float) 1 zodi brightness magnitude (per arcsec2).
\item[magEZ] (float) 1 exo-zodi brightness magnitude (per arcsec2).
\item[varEZ] (float) exo-zodiacal light variation (variance of log-normal distribution).

\item[\textbf{PostProcessing}]
\item[FAP] (float) False Alarm Probability.
\item[MDP] (float) Missed Detection Probability.
\item[ppFact] (float, callable) Post-processing contrast factor, between 0 and 1.
\item[FAdMag0] (float, callable) Minimum delta magnitude that can be obtained by a false alarm.

\item[\textbf{Completeness}]
\item[dMagLim] (float) Limiting planet-to-star delta magnitude for completeness.
\item[minComp] (float) Minimum completeness value for inclusion in target list.

\item[\textbf{TargetList}]
\item[staticStars] (boolean) Boolean used to force static target positions set at mission start time.
\item[keepStarCatalog] (boolean) Boolean representing whether to delete the star catalog after assembling the target list.  If true, object reference will be available from TargetList object.

\item[\textbf{Observatory}]
\item[koAngles\_SolarPanel] (numpy array) angular region telescope can observe stars due to solar panels in units $deg$.
\item[koAngles\_Sun] (numpy array) angular region telescope can observe stars due to Sun in units $deg$.
\item[koAngles\_Earth] (numpy array) angular region telescope can observe stars due to Earth in units $deg$.
\item[koAngles\_Moon] (numpy array) angular region telescope can observe stars due to Moon in units $deg$.
\item[koAngles\_Small] (numpy array) angular region telescope can observe stars due to all other planets in units $deg$.
\item[settlingTime] (float) Amount of time needed for observatory to settle after a repointing in units of $ day $.
\item[thrust] (float) Occulter slew thrust in units of $ mN $.
\item[slewIsp] (float) Occulter slew specific impulse in units of $ s $.
\item[scMass] (float) Occulter (maneuvering spacecraft) initial wet mass in units of $ kg $. 
\item[dryMass] (float) Occulter (maneuvering spacecraft) dry mass in units of $ kg $.
\item[twotanks] (boolean) Boolean signifying if the Occulter (maneuvering spacecraft) has two separate fuel tanks. If true, decrements mass from slewMass and skMass.
\item[slewMass] (float) Occulter (maneuvering spacecraft) initial fuel mass used for slewing in units of $ kg $.
\item[skMass] (float) Occulter (maneuvering spacecraft) initial fuel mass used for station keeping in units of $ kg $.
\item[slewEff] (float) Occulter slewing maneuver general efficiency factor.
\item[skEff] (float) Occulter station keeping maneuver general efficiency factor.
\item[coMass] (float) Telescope (or non-maneuvering spacecraft) mass in units of $ kg $. 
\item[occulterSep] (float) Occulter-telescope distance in units of $ km $. 
\item[skIsp] (float) Specific impulse for station keeping in units of $ s $. 
\item[defburnPortion] (float) Default burn portion for slewing.
\item[constTOF] (float) Constant time of flight for single occulter slew in units of $ day $
\item[maxdVpct] (float) Maximum percentage of total on board fuel used for single starshade slew
\item[spkpath] (string) Full path to SPK kernel file.
\item[checkKeepoutEnd] (boolean) Boolean signifying if the keepout method must be called at the end of each observation.
\item[forceStaticEphem]  (boolean) Force use of static solar system ephemeris if set to True, even if jplephem module is present.

\item[\textbf{TimeKeeping}]
\item[missionStart] (float) Mission start time in $ MJD $. 
\item[missionLife] (float) The total mission lifetime in units of $ year $.  When the mission time is equal or greater to this value, the mission simulation stops.
\item[missionPortion] (float) The portion of the mission dedicated to exoplanet science, given as a value between 0 and 1. The mission simulation stops when the total integration time plus observation overhead time is equal to the missionLife $\times$ missionPortion.
\item[OBduration] (float) Default allocated duration of observing blocks, in units of $day$. If no OBduration was specified, a new observing block is created for each new observation in the SurveySimulation module.
\item[missionSchedule] (string) filename of csv file containing Observing Block start and end times.

\item[\textbf{SurveySimulation}]
\item[scriptfile] (string) name of the scriptfile to load json script parameters from
\item[ntFlux] (integer) Observation time sampling, to determine the integration time interval.
\item[nVisitsMax] (integer) Maximum number of observations (in detection mode) per star. 
\item[charMargin] (float) Integration time margin for characterization. 
\item[WAint] (float) Working angle used for integration time calculation in units of $arcsec$.
\item[dMagint] (float) Delta magnitude used for integration time calculation.
\item[dt\_max] (float) The maximum time for a revisit window in units of weeks.
\item[cachedir] (string) path to desired cache directory (default is \texttt{\$HOME/.EXOSIMS/cache})


\end{itemize}

\section{Prototype Module Specifications}\label{sec:modules}
The lower level modules include Planet Population, Star Catalog, Optical System, Zodiacal Light, Background Sources, Planet Physical Model, Observatory, Time Keeping, and Post-Processing.  These modules encode and/or generate all of the information necessary to perform mission simulations.  The specific mission design determines the functionality of each module, while inputs and outputs of these modules remain the same (in terms of data type and variable representations).  

The upstream modules include Completeness, Target List, Simulated Universe, Survey Simulation and Survey Ensemble. These modules perform methods which require inputs from one or more downstream modules as well as calling function implementations in other upstream modules. 

This section defines the functionality, major tasks, input, output, and interface of each of these modules. Every module constructor must always accept a keyword dictionary (\verb+**spec+) representing the contents of the specification JSON file organized into a Python dictionary. The descriptions below list out specific keywords that are pulled out by the prototype constructors of each of the modules, but implemented constructors may include additional keywords (so long as they correctly call the prototype constructor).  In all cases, if a given \verb+key:value+ pair is missing from the dictionary, the appropriate object attributes will be assigned the default values listed.


% STAR CATALOG
\subsection{Star Catalog} \label{sec:starcatalog}
The Star Catalog module includes detailed information about potential target stars drawn from general databases such as SIMBAD, mission catalogs such as Hipparcos, or from existing curated lists specifically designed for exoplanet imaging missions.  Information to be stored, or accessed by this module will include target positions and proper motions at the reference epoch, catalog identifiers (for later cross-referencing), bolometric luminosities, stellar masses, and magnitudes in standard observing bands.  Where direct measurements of any value are not available, values are synthesized from ancillary data and empirical relationships, such as color relationships and mass-luminosity relations.

This module does not provide any functionality for picking the specific targets to be observed in any one simulation, nor even for culling targets from the input lists where no observations of a planet could take place.  This is done in the Target List module as it requires interactions with the Planet Population (to determine the population of interest), Optical System (to define the capabilities of the instrument), and Observatory (to determine if the view of the target is unobstructed) modules.

\subsubsection{Star Catalog Object Attribute Initialization} 
The Star Catalog prototype creates empty 1D NumPy ndarrays for each of the output quantities listed below.  Specific Star Catalog modules must populate the values as appropriate.  Note that values that are left unpopulated by the implementation will still get all zero array, which may lead to unexpected behavior.

\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[star catalog information] \hfill \\
    Information from an external star catalog (left deliberately vague as these can be anything).
\end{description}
\end{itemize}

\subsubsection*{Attributes}
\begin{itemize}
\item 
\begin{description}
    \item[ntargs (integer)] \hfill \\ Number of stars
    \item[Name (string ndarray)] \hfill \\ Star names
    \item[Spec (string ndarray)] \hfill \\ Spectral types
    \item[Umag (float ndarray)] \hfill \\ U magnitude
    \item[Bmag (float ndarray)] \hfill \\ B magnitude
    \item[Vmag (float ndarray)] \hfill \\ V magnitude
    \item[Rmag (float ndarray)] \hfill \\ R magnitude
    \item[Imag (float ndarray)] \hfill \\ I magnitude
    \item[Jmag (float ndarray)] \hfill \\ J magnitude
    \item[Hmag (float ndarray)] \hfill \\ H magnitude
    \item[Kmag (float ndarray)] \hfill \\ K magnitude
    \item[BV (float ndarray)] \hfill \\ B-V Johnson magnitude
    \item[MV (float ndarray)] \hfill \\ Absolute V magnitude
    \item[BC (float ndarray)] \hfill \\ Bolometric correction
    \item[L (float ndarray)] \hfill \\ Stellar luminosity in Solar luminosities
    \item[Binary\_Cut (boolean ndarray)] \hfill \\ Booleans where True is a star with a companion closer than $ 10 arcsec $
    \item[dist (astropy Quantity array)] \hfill \\ Distance to star in units of $ pc $. Defaults to 1.
    \item[parx (astropy Quantity array)] \hfill \\ Parallax in units of $ mas $. Defaults to 1000.
    \item[coords (astropy SkyCoord array)] \hfill \\ \href{http://astropy.readthedocs.org/en/latest/api/astropy.coordinates.SkyCoord.html}{SkyCoord object} containing right ascension, declination, and distance to star in units of $ deg $, $ deg $, and $ pc $.
    \item[pmra (astropy Quantity array)] \hfill \\ Proper motion in right ascension in units of $ mas/year $
    \item[pmdec (astropy Quantity array)] \hfill \\ Proper motion in declination in units of $ mas/year $
    \item[rv (astropy Quantity array)] \hfill \\ Radial velocity in units of $ km/s $
    \item[cachedir (string)] \hfill \\ Path to cache directory
\end{description}
\end{itemize}


% PLANET POPULATION

\subsection{Planet Population}
The Planet Population module encodes the probability density functions of all required planetary parameters, both physical and orbital, as well as generating functions to return samples of these parameters. The planet is described by its semi-major axis, eccentricity, orbital orientation, radius, mass, and geometric albedo (see \S\ref{sec:pdfs}). Certain parameter models may be empirically derived while others may come from analyses of observational surveys.  This module also encodes the limits on all parameters to be used for sampling the distributions and determining derived cutoff values such as the maximum target distance for a given instrument's IWA.

\begin{figure}[ht]
    \begin{center}
        \begin{tabular}{c}
             \includegraphics[width=0.6\textwidth]{orbit_diagram}
        \end{tabular}
    \end{center}
    \caption{\label{fig:orbit_diagram} Definition of reference frames and coordinates of simulated exosystems.  The observer lies along the negative $\mf s_3$ axis so that the observer-star unit vector is $+\mf s_3$.}
\end{figure}

The coordinate system of the simulated exosystems is defined as in \reffig{fig:orbit_diagram}.  The observer looks at the target star ($r_{targ}$ in the observatory module) along the $\mathbf{s}_3$ axis. The observer is located $-d\mathbf{s_3}$ from the target star at the time of observation where $d$ is the distance between the observer and the target star. The argument of periapse, inclination,  and longitude of the ascending node ($\omega, I, \Omega$) are defined as a 3-1-3 rotation about the unit vectors defining the $\mathcal{S}$ reference frame.  This rotation defines the standard Equinoctial reference frame ($\mfhat{e}, \mfhat{q}, \mfhat{h}$), with the true anomaly ($\nu$) measured from the eccentricity unit vector ($\mfhat{e}$), which points in the direction of periapse.  The planet-star orbital radius vector $\mf r_{P/S}$ (this is the SimulatedUniverse attribute r) is projected into the $\mf s_1, \mf s_2$ plane as the projected separation vector $\mf s$, with magnitude $s$, and the phase (star-planet-observer) angle ($\beta$) is closely approximated by the angle between $\mf r_{P/S}$ and its projection onto $\mf s_3$. The parallactic angle of the planet (not drawn) is the angle formed between $\mf s_1$ and $\mf s$ in the clockwise direction.

\bigskip

\noindent\emph{Note: The Planet Population module does not model the physics of planetary orbits or the amount of light reflected or emitted by a given planet, but rather encodes the statistics of planetary occurrence and properties. }

\label{sec:planetpopulation}
\subsubsection{Planet Population Object Attribute Initialization} 
\subsubsection*{Input}
The following are all entries in the passed specs dictionary (derived from the JSON script file or another dictionary).  Values not specified will be replaced with defaults, as listed.  It is important to note that many of these (in particular mass and radius) may be mutually dependent, and so some implementations may choose to only use some for inputs and set the rest via the physical models. The \verb+gen_input_check+ method is a helper method to check whether the input is an integer. The \verb+checkranges+ method is a helper method checking range validity on 2 element lists of ranges.
\begin{itemize}
\item
\begin{description}
    \item[arange (float 1$\times$2 array)] \hfill \\ Semi-major axis range in units of $ AU $. Default value is [0.01, 100]
    \item[erange (float 1$\times$2 array)] \hfill \\ Eccentricity range.  Default value is [0.01,0.99]
    \item[Irange (float 1$\times$2 array)] \hfill \\ Inclination range in units of $ deg $.  Default value is [0,180]
    \item[Orange (float 1$\times$2 array)] \hfill \\ Ascension of the ascending node range in units of $ deg $.  Default value is [0,360]
    \item[wrange (float 1$\times$2 array)] \hfill \\ Argument of periastron range in units of $ deg $.  Default value is [0,360]
    \item[prange (float 1$\times$2 array)] \hfill \\ Planetary geometric albedo range.  Default value is [0.1,0.6]
    \item[Rprange (float 1$\times$2 array)] \hfill \\ Planetary Radius in Earth radii.  Default value is [1, 30]
    \item[Mprange (float 1$\times$2 array)] \hfill \\ Planetary mass in Earth masses.  Default value is [1, 4131]
    \item [scaleOrbits (boolean)] \hfill \\ Boolean where True means planetary orbits are scaled by the square root of stellar luminosity. Default value is False.
    \item[constrainOrbits (boolean)] \hfill \\ Boolean where True means planetary orbits are constrained to never leave the semi-major axis range (arange). Default value is False.
    \item[eta (float)] \hfill \\ The average occurrence rate of planets per star for the entire population.  The expected number of planets generated per simulation is equal to the product of eta with the total number of targets.  Note that this is the expectation value \emph{only}---the actual number of planets generated in a given simulation may vary depending on the specific method of sampling the population.
\end{description}
\end{itemize}
\subsubsection*{Attributes}
\begin{itemize}
\item
\begin{description}
    \item[PlanetPhysicalModel (PlanetPhysicalModel module)] \hfill \\ PlanetPhysicalModel class object
    \item[arange (astropy Quantity 1$\times$2 array)] \hfill \\ Semi-major axis range defined as [a\_min, a\_max] in units of $ AU $
    \item[erange (float 1$\times$2 ndarray)] \hfill \\ Eccentricity range defined as [e\_min, e\_max]
    \item[Irange (astropy Quantity 1$\times$2 array)] \hfill \\ Planetary orbital inclination range defined as [I\_min, I\_max] in units of $ deg $
    \item[Orange (astropy Quantity 1$\times$2 array)] \hfill \\ Right ascension of the ascending node range defined as [O\_min, O\_max] in units of $ deg $
    \item[wrange (astropy Quantity 1$\times$2 array)] \hfill \\ Argument of periastron range defined as [w\_min, w\_max] in units of $ deg $
    \item[prange (float 1$\times$2 ndarray)] \hfill \\ Planetary geometric albedo range defined as [p\_min, p\_max]
    \item[Rprange (astropy Quantity 1$\times$2 array)] \hfill \\ Planetary radius range defined as [R\_min, R\_max] in units of $earthRad$
    \item[Mprange (astropy Quantity 1$\times$2 array)] \hfill \\ Planetary mass range defined as [Mp\_min, Mp\_max] in units of $earthMass$
    \item[rrange (astropy Quantity 1$\times$2 array)] \hfill \\ Planetary orbital radius range defined as [r\_min, r\_max] derived from PlanetPopulation.arange and PlanetPopulation.erange, in units of $ AU $
    \item [scaleOrbits (boolean)] \hfill \\ Boolean where True means planetary orbits are scaled by the square root of stellar luminosity.
    \item[constrainOribts (boolean)] \hfill \\ Boolean where True means planetary orbits are constrained to never leave the semi-major axis range (arange). If set to True, an additional method (\verb+gen_eccen_from_sma+) must be provided by the implementation---see below.
    \item[eta (float)] \hfill \\ The average occurrence rate of planets per star for the entire population.
    \item[uniform (float, callable)] \hfill \\ Uniform distribution over a given range.
    \item[logunif (float, callable)] \hfill \\ Log-uniform distribution over a given range.
    \item[cachedir (string)] \hfill \\ Path to cache directory.
\end{description}
\end{itemize}

\subsubsection{Planet Population Value Generators} \label{sec:pdfs}
For each of the parameters represented by the input attributes, the planet population object will provide a method that returns random values for the attributes, within the ranges specified by each attribute (so that, for example, there will be samples of semi-major axis corresponding to \verb+arange+, etc.).  Each of these methods will take a single input of the number of values to generate.  These methods will encode the probability density functions representing each parameter, and use either a rejection sampler or other (numpy or scipy) provided sampling method to generate random values.  All returned values will have the same type/default units as the attributes. 

In cases where values need to be sampled jointly (for example if you have a joint distribution of semi-major axis and planetary radius) then the sampling will be encoded in the \verb+gen_plan_params+ function.  In cases where there is a deterministic calculation of one parameter from another (as in mass calculated from radius) this will be provided separately in the Planet Physical module. Any non-standard distribution functions being sampled by one of these methods should be created as object attributes in the implementation constructor so that they are available to other modules.
\\\\
The methods are:
\begin{itemize}[leftmargin=1.5in,font={\ttfamily}]
    \item[\texttt gen\_plan\_params] Returns values of semi-major axis (in units of $ AU $), eccentricity, geometric albedo, and planetary radius (in units of $ earthRad $)
    \item[\texttt gen\_angles] Returns values of orbital inclination, longitude of the ascending node, and argument of periastron, all in units of $ deg $
    \item[\texttt gen\_mass] Returns planetary mass values in units of $earthMass$
    \item[\texttt dist\_sma] Provides the probability density function for the semi-major axis
    \item[\texttt dist\_eccen] Provides the probability density function for the eccentricity
    \item[\texttt dist\_eccen\_from\_sma] Provides the probability density function for the eccentricity given a value of semi-major axis. This function is used when \verb+constrainOrbits+ is set to \verb+True+.
    \item[\texttt dist\_albedo] Provides the probability density function for the albedo
    \item[\texttt dist\_radius] Provides the probability density function for the radius
    \item[\texttt dist\_mass] Provides the probability density function for the mass
\end{itemize}


% PLANET PHYSICAL MODEL 

\subsection{Planet Physical Model} \label{sec:planetphysicalmodel}
The Planet Physical Model module contains models of the light emitted or reflected by planets in the wavelength bands under investigation by the current mission simulation.  It takes as inputs the physical quantities sampled from the distributions in the Planet Population module and generates synthetic spectra (or band photometry, as appropriate).  The specific implementation of this module can vary greatly, and can be based on any of the many available planetary geometric albedo, spectra and phase curve models.  This module contains the attribute \texttt{cachedir}, the path to the cache directory.

This module also contains the attribute \texttt{whichPlanetPhaseFunction}, the string indicating which planet phase function model to use. These planet phase functions manifest themselves as the \texttt{calc\_Phi} method and originate from the \texttt{phaseFunctions} script in \texttt{utils}. Currently, the default is to use the Lambert phase function. Optional alternatives include \texttt{quasiLambertPhaseFunction}, \texttt{hyperbolicTangentPhaseFunc}, or \texttt{realSolarSystemPhaseFunc}.

As required, this module also provides physical models relating dependent parameters that cannot be sampled independently (for example density models relating plant mass and radius).  While the specific methods will depend highly on the physical models being used, the prototype provides four stubs that will be commonly useful:
\begin{itemize}[leftmargin=2in,font={\ttfamily}]
    \item[\texttt calc\_albedo\_from\_sma] Calculate planetary geometric albedo as a function of the semi-major axis. (see \S\ref{sec:calcalbedofromsmatask})
    \item[\texttt calc\_radius\_from\_mass] Calculate planetary radii from their masses (see \S\ref{sec:calcradiusfrommasstask}).
    \item[\texttt calc\_mass\_from\_radius] Calculate planetary masses from their radii (see \S\ref{sec:calcmassfromradiustask}).
    \item[\texttt calc\_Phi] Calculate the value of the planet phase function given its phase angle. The prototype implementation uses the Lambert phase function (see \S\ref{sec:calcphitask}).
    \item[\texttt calc\_Teff] Calcluate the effective planet temperature given the stellar luminosity, planet albedo and star-planet distance (see \S\ref{sec:calcteff}).
\end{itemize}

\subsubsection{calc\_albedo\_from\_sma Method} \label{sec:calcalbedofromsmatask}
Helper function for calculating albedo given the semi-major axis. The prototype provides only a dummy function that always returns the same value of 0.367.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[a (astropy Quantity array)] \hfill \\ Semi-major axis values
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[p (ndarray)] \hfill \\ Albedo values
\end{description}
\end{itemize}

\subsubsection{calc\_radius\_from\_mass Method} \label{sec:calcradiusfrommasstask}
Helper function for calculating radius given the mass. Prototype provides only a dummy function that assumes a density of water.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[Mp (astropy Quantity array)] \hfill \\ Planet mass in units of Earth mass
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[Rp (astropy Quantity arrau)] \hfill \\ Planet radius in units of Earth radius
\end{description}
\end{itemize}

\subsubsection{calc\_mass\_from\_radius) Method} \label{sec:calcmassfromradiustask}
Helper function for calculating mass given the radius.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[Rp (astropy Quantity array)] \hfill \\ Planet radius in units of Earth radius
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[Mp (astropy Quantity array)] \hfill \\ Planet mass in units of Earth mass
\end{description}
\end{itemize}

\subsubsection{calc\_Phi Method} \label{sec:calcphitask}
Calculate the phase function. Prototype method uses the Lambert phase function from Sobolev 1975.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[beta (astropy Quantity array)] \hfill \\ Planet phase angles at which the phase function is to be calculated, in units of rad
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[Phi (ndarray)] \hfill \\ Planet phase function
\end{description}
\end{itemize}

\subsubsection{calc\_Teff Method} \label{sec:calcteff}
Calcluates the effective planet temperature given the stellar luminosity, planet albedo and star-planet distance. This calculation represents a basic balckbody power balance, and does not take into account the actual emmisivity of the planet, or any non-equilibrium effects or temperature variations over the surface. \\
Note:  The input albedo is taken to be the bond albedo, as required by the equilibrium calculation. For an isotropic scatterer (Lambert phase function) the Bond albedo is 1.5 times the geometric albedo. However, the Bond albedo must be strictly defined between 0 and 1, and an albedo of 1 produces a zero effective temperature.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[starL (float ndarray)] \hfill \\ Stellar luminosities in units of solar luminosity. Not an astropy quantity.
    \item[d (astropy Quantity array)] \hfill \\ Star-planet distances
    \item[p (float ndarray)] \hfill \\ Planet albedos
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[Teff (astropy Quantity)] \hfill \\ Planet effective temperature in degrees K
\end{description}
\end{itemize}

% OPTICAL SYSTEM

\subsection{Optical System}
The Optical System module contains all of the necessary information to describe the planet signal and background noise fluxes at the image plane of all relevant instruments, and calculate the required integration time for a given observation.  This also requires encoding the design of the telescope including the attenuation due to all optical elements that are not explicitly part of the starlight suppression system, the area of the entrance pupil, and the fraction of that area that is obscured (by spiders and secondary mirror). A description of the science instruments is also required, including detector details such as read noise, dark current, and readout cycle. The baseline is assumed to be an imager and a spectrograph. Finally, the Optical System must include the performance of all starlight suppression systems, which are broadly grouped as internal coronagraphs and external occulters. The Optical System module also contains a required dictionary of all potential mission observing modes. Each mode is defined by a combination of a science instrument and a starlight suppression system, operating in a set spectral window (bandpass). Note that there is no requirement that the bandpass of the instrument be exactly matched to the bandpass of the science instrument.  It is up to the user to ensure that the modes are defined consistently, and scaling of all relevant values to the selected central wavelength will occur automatically.

The starlight suppression system throughput and contrast - or residual intensity - can be encoded with angular separation and wavelength dependant definitions. Some specific Optical System modules may also require encoding the Point Spread Functions (PSF) for on- and off-axis sources. At the opposite level of complexity, the encoded portions of this module may be a description of all of the optical elements between the telescope aperture and the science camera, along with a method of propagating an input wavefront to the final image plane.  Intermediate implementations can include partial propagations, or collections of static PSFs representing the contributions of various system elements.  The encoding of the optical train will allow for the extraction of specific bulk parameters including the instrument inner working angle (IWA), outer working angle (OWA), and mean and max contrast and throughput.

By definition, the detection mode IWA correspond to the working angle at which integration times are calculated during the detection phase. This IWA must not be confused with the global IWA. There are 3 types of IWA/OWA:\\
1- Each coronagraph has its own IWA/OWA in arcsec defined at its operation wavelength.\\
2- Each observing mode has its own IWA/OWA, based on the coronagraph IWA/OWA and rescaled to the model's specific wavelength. For simple cases where no observing modes are specified, the detection IWA will simply correspond to the coronagraph IWA.\\
3- A global IWA/OWA can be specified for the whole telescope, to filter out targets during the initialization, thus before the mission starts. By defaults, the global IWA = minimum(mode\_IWAs) and global OWA = maximum(mode\_OWAs). However, the user can specify a global IWA that is very small or even zero to avoid filtering out targets during initialization, without affecting the detection IWA described above.

The input and output of the Optical System methods are depicted in \reffig{fig:opticalsysmodule}. The Optical System module has six methods used in simulation:
\begin{itemize}[leftmargin=2in,font={\ttfamily}]
    \item[\texttt get\_coro\_param] Called in OpticalSystem constructor to create a lambda function from a given starlight suppression system fits file
    \item[\texttt Cp\_Cb\_Csp] Called by \verb+calc_intTime+ to calculate the electron count rates for planet signal, background noise, and speckle residuals (see \S\ref{sec:CpCbCsptask}).
    \item[\texttt calc\_intTime] Calculates the integration times for specific values of planet zodiacal noise, delta magnitude, and angular separation (see \S\ref{sec:calcintTimetask}).
    \item[\texttt calc\_minintTime] Calculates the minimum integration times for all the stars from the target list, using optimistic input parameters  (see \S\ref{sec:calcminintTimetask}).
    \item[\texttt calc\_dMag\_per\_intTime] Calculates achievable planet delta magnitude per integration time (see \S\ref{sec:calcdMagperintTime}).
    \item[\texttt ddMag\_dt] Calculates derivative of achievable delta mag per integration time (see \S\ref{sec:ddMagdt}).
\end{itemize}

\begin{figure}[ht]
    \begin{center}
        \begin{tabular}{c}
            \includegraphics[width=\textwidth]{OpticalSystem}
        \end{tabular}
    \end{center}
    \caption{\label{fig:opticalsysmodule} Depiction of Optical System module methods including input and output (see \S\ref{sec:CpCbCsptask}, \S\ref{sec:calcintTimetask}).}
\end{figure}

\label{sec:opticalsystem}
\subsubsection{Optical System Object Attribute Initialization} 

The specific set of inputs to this module will vary based on the simulation approach used.  Here we define the specification for the case where static PSF(s), derived from external diffraction modeling, are used to describe the system.  Note that some of the inputs are specific to "internal" or "external" (i.e. starshade) systems and will be expected based on the $occulter$ flag.

\subsubsection*{Input}

\begin{itemize}
\item 
\begin{description}
    \item[obscurFac (float)] \hfill \\ Obscuration factor due to secondary mirror and spiders. Default value is 0.1.
    \item[shapeFac (float)] \hfill \\ Shape factor of the unobscured pupil area, so that $ shapeFac \times pupilDiam^2  \times (1-obscurFac) = pupilArea $. Default value is $ \frac{\pi}{4} $.
    \item[pupilDiam (float)] \hfill \\ Entrance pupil diameter in  $ m $. Default value is 4.
    \item[IWA (float)] \hfill \\ Fundamental Inner Working Angle in units of $ arcsec $. No planets can ever be observed at smaller separations. If not set, defaults to smallest IWA of all starlightSuppressionSystems.
    \item[OWA (float)] \hfill \\ Fundamental Outer Working Angle in units of $ arcsec $. Set to $ Inf $ for no OWA. If not set, defaults to largest OWA of all starlightSuppressionSystems. JSON values of 0 will be interpreted as $ Inf $.
    \item[intCutoff (float)] \hfill \\ Maximum allowed integration time in units of $ day $. No integration will be started that would take longer than this value. Default value is 50.
    \item[dMag0 (float)] \hfill \\  Favorable planet delta magnitude value used to calculate the minimum integration times for inclusion in target list.
    \item[WA0 (float)] \hfill \\  Instrument working angle value used to calculate the minimum integration times for inclusion in target list (defaults to detection IWA-OWA midpoint), in units of $arcsec$.
    \item[scienceInstruments (list of dicts)] \hfill\\ List of dictionaries containing specific attributes of all science instruments. For each instrument, if the below attributes are missing from the dictionary, they will be assigned the default values listed, or any value directly passed as input to the class constructor. 
    \begin{description}
        \item[name (string)] \hfill\\ (Required) Instrument name (e.g. imager-EMCCD, spectro-CCD), should contain the type of instrument (imager or spectro). Every instrument should have a unique name.
        \item[QE (float, callable)] \hfill \\ Detector quantum efficiency: either a scalar for constant QE, or a two-column array for wavelength-dependent QE, where the first column contains the wavelengths in units of $ nm $. May be data or FITS filename. Default is scalar 0.9. 
        \item[optics (float)] \hfill \\ Attenuation due to optics specific to the science instrument. Default value is 0.5.
        \item[FoV (float)] \hfill \\ Field of view in units of $ arcsec $. Default value is 10.
        \item[pixelNumber (integer)] \hfill \\ Detector array format, number of pixels per detector lines/columns. Default value is 1000.
        \item[pixelSize (float)] \hfill \\ Pixel pitch in units of $ m $. Default value is 1e-5. 
        \item[sread (float)] \hfill \\ Detector effective read noise per frame per pixel, including any gain (e.g. electron multiplication gain). Default value is 1e-6.
        \item[idark (float)] \hfill \\ Detector dark-current per pixel in units of $ 1/s $. Default value is 1e-4. 
        \item[CIC (float)] \hfill \\ (Specific to CCDs) Clock-induced-charge per frame per pixel. Default value is 1e-3. 
        \item[texp (float)] \hfill \\ Exposure time per frame in units of $ s $. Default value is 100. 
        \item[radDos (float)] \hfill \\ Radiation dosage. Default value is 0.
        \item[PCeff (float)] \hfill \\ Photon counting efficiency. Default value is 0.8.
        \item[ENF (float)] \hfill \\ (Specific to EM-CCDs) Excess noise factor. Default value is 1.
        \item[Rs (float)] \hfill \\ (Specific to spectrometers) Spectral resolving power defined as $\lambda/d\lambda$. Default value is 50. 
        \item[lenslSamp (float)] \hfill \\ (Specific to spectrometers) Lenslet sampling, number of pixel per lenslet rows or cols. Default value is 2.
    \end{description}
    \item[starlightSuppressionSystems (list of dicts)] \hfill\\ List of dictionaries containing specific attributes of all starlight suppression systems. For each system, if the below attributes are missing from the dictionary, they will be assigned the default values listed, or any value directly passed as input to the class constructor. In case of multiple systems, specified wavelength values (lam, deltaLam, BW) of the first system become the new default values.
    
    The following items can be encoded either as scalar parameters, or as two-column arrays for angular separation-dependent parameters, where the first column contains the separations in units of $ arcsec $, or as 2D array for angular separation- and wavelength- dependent parameters, where the first column contains the angular separation values in units of $ arcsec $ and the first row contains the wavelengths in units of $ nm $: $occ\_trans$, $core\_thruput$, $core\_contrast$, $core\_mean\_intensity$, $core\_area$. 
    \begin{description}
        \item[name (string)] \hfill \\ (Required) System name (e.g. HLC-500, SPC-700), should also contain the central wavelength the system is optimized for. Every system must have a unique Name. 
        \item[optics (float)] \hfill \\ Attenuation due to optics specific to the coronagraph, e.g. polarizer, Lyot stop, extra flat mirror. Default value is 1.
        \item[lam (float)] \hfill \\ Central wavelength $\lambda$ in units of $ nm $. Default value is 500. 
        \item[deltaLam (float)] \hfill \\ Bandwidth $ \Delta\lambda $ in units of $ nm $. Defaults to lambda $ \times $ BW (defined hereunder).
        \item[BW (float)] \hfill \\ Bandwidth fraction $(\Delta\lambda/\lambda)$. Only applies when deltaLam is not specified. Default value is 0.2.
        \item[IWA (float)] \hfill \\ Inner Working Angle of this system in units of $ arcsec $. If not set, or if too small for this system contrast/throughput definitions, defaults to smallest WA of contrast/throughput definitions.
        \item[OWA (float)] \hfill \\ Specific Outer Working Angle of this system in units of $ arcsec $. Set to $ Inf $ for no OWA. If not set, or if too large for this system contrast/throughput definitions, defaults to largest WA of contrast/throughput definitions.  JSON values of $ 0 $ will be interpreted as $ Inf $.
        \item[occ\_trans (float, callable)] \hfill \\ Intensity transmission of extended background sources such as zodiacal light. Includes pupil mask, occulter, Lyot stop and polarizer. Default is scalar 0.2.
        \item[core\_thruput (float, callable)] \hfill \\ System throughput in the FWHM region of the planet PSF core. Default is scalar 0.1.
        \item[core\_contrast (float, callable)] \hfill \\ System contrast defined as the starlight residual normalized intensity in the PSF core, divided by the core throughput. Default is scalar 1e-10.
        \item[core\_mean\_intensity (float, callable)] \hfill \\ Mean starlight residual normalized intensity per pixel, required to calculate the total core intensity as $core\_mean\_intensity \times Npix$. If not specified, then the total core intensity is equal to $core\_contrast \times core\_thruput$.
        \item[core\_area (float, callable)] \hfill \\ Area of the FWHM region of the planet PSF, in units of $ arcsec^2 $. If not specified, the default core area is equal to $\pi\left(\frac{\sqrt 2}{2}\frac{\lambda}{D}\right)^2$.
        \item[core\_platescale (float)] \hfill \\ Platescale used for a specific set of coronagraph parameters, in units of lambda/D per pixel. Defaults to the instrument pixelScale.
        \item[ohTime (float)] \hfill \\ Optical system overhead time in units of $ day $.  Default value is 1.  This is the (assumed constant) amount of time required to set up the optical system (i.e., dig the dark hole or do fine alignment with the occulter).  It is added to every observation, and is separate from the observatory overhead defined in the observatory module, which represents the observatory's settling time.  Both overheads are added to the integration time to determine the full duration of each detection observation.
        \item[occulter (boolean)] \hfill \\ True if the system has an occulter (external or hybrid system), otherwise False (internal system)
        \item[occulterDiameter (float)]\hfill \\ Occulter diameter in units of $ m $.  Measured petal tip-to-tip.
        \item [NocculterDistances (integer)]\hfill \\ Number of telescope separations the occulter operates over (number of occulter bands). If greater than 1, then the occulter description is an array of dicts.
        \item[occulterDistance (float)] \hfill \\ Telescope-occulter separation in units of $km$.
        \item[occulterBlueEdge (float)]\hfill \\ Occulter blue end of wavelength band in units of $nm$.
        \item[occulterRedEdge (float)]\hfill \\ Occulter red end of wavelength band in units of $nm$.
    \end{description}
    \item[observingModes (list of dicts)]\hfill \\ List of dictionaries containing specific attributes of all mission observing modes. Each observing mode is a combination of an instrument and a system, operating at a given wavelength, which by default is the wavelength defined in the starlight suppression system of the observing mode. If an observing mode is operating at a different wavelength than the system default wavelength, then this new wavelength must be added to the observing mode, and the system performance will be automatically rescaled to the new wavelength. If no observing mode is defined, the default observing mode simply combines the first instrument and the first system.
    
    \begin{description}
        \item[instName (string)]\hfill \\ (Required) Instrument name. Must match with the name of a defined science instrument.
        \item[systName (string)]\hfill \\ (Required) System name. Must match with the name of a defined starlight suppression system.
        \item[inst (dict)]\hfill \\ Selected instrument of the observing mode.
        \item[syst (dict)]\hfill \\ Selected system of the observing mode.
        \item[detectionMode (boolean)]\hfill \\ True if this observing mode is the detection mode, otherwise False. Only one detection mode can be specified. If not specified, default detection mode is first imager mode.
        \item[SNR (float)]\hfill \\ Signal-to-noise ratio threshold. Defaults to 5.
        \item[timeMultiplier (float)]\hfill \\ Integration time multiplier. Equal to the number of discrete integrations needed to cover the full field of view (e.g. shaped pupil), or the full wavelength band and all required polarization states.  For example, if the band is split into three sub-bands, and there are two polarization states that must be measured, and each of these must be done sequentially, then this value would equal 6.  However, if the three sub-bands could be observed at the same time (e.g., by separate detectors) then the value would be two (for the two polarization states). Defaults to 1.
        \item[lam (float)]\hfill \\ Central wavelength in units of nm. Defaults to corresponding system value.
        \item[deltaLam (float)]\hfill \\ Bandwidth in units of nm. Defaults to corresponding system value.
        \item[BW (float)]\hfill \\ Bandwidth fraction. Defaults to corresponding system value.
    \end{description}
\end{description}
\end{itemize}
For all values that may be either scalars or interpolants, in the case where scalar values are given, the optical system module will automatically wrap them in lambda functions so that they become callable (just like the interpolant) but will always return the same value for all arguments.  The inputs for interpolants may be filenames (full absolute paths) with tabulated data, or NumPy ndarrays of argument and data (in that order in rows so that input[0] is the argument and input[1] is the data).  When the input is derived from a JSON file, these must either be scalars or filenames.

The starlight suppression system and science instrument dictionaries can contain any other attributes required by a particular optical system implementation.  The only significance of the ones enumerated above is that they are explicitly checked for by the prototype constructor, and cast to their expected values.

\subsubsection*{Attributes}
These will always be present in an OpticalSystem object and directly accessible as \verb+OpticalSystem.Attribute+.
\begin{itemize}
\item 
\begin{description}
    \item[obscurFac (float)] \hfill \\ Obscuration factor due to secondary mirror and spiders
    \item[shapeFac (float)] \hfill \\ Shape factor of the unobscured pupil area, so that $ shapeFac \times pupilDiam^2  \times (1-obscurFac) = pupilArea $
    \item[pupilDiam (astropy Quantity)] \hfill \\ Entrance pupil diameter in units of $ m $
    \item[pupilArea (astropy Quantity)] \hfill \\ Entrance pupil area in units of $ m^{2} $
    \item[haveOcculter (boolean)] \hfill \\ Boolean signifying if the system has an occulter
    \item[IWA (astropy Quantity)] \hfill \\ Fundamental Inner Working Angle in units of $ arcsec $
    \item[OWA (astropy Quantity)] \hfill \\ Fundamental Outer Working Angle in units of $ arcsec $
    \item[intCutoff (astropy Quantity)] \hfill \\ Maximum allowed integration time in units of $ day $
    \item[dMag0 (float)] \hfill \\  Favorable planet delta magnitude value used to calculate the minimum integration times for inclusion in target list.
    \item[WA0 (astropy Quantity)] \hfill \\  Instrument working angle value used to calculate the minimum integration times for inclusion in target list.
    \item[scienceInstruments (list of dicts)] \hfill \\  List of dictionaries containing all supplied science instrument attributes.  Typically the first instrument will be the imager, and the second the spectrograph (IFS). Only required attribute is `name'.  See above for other commonly used attributes. 
    \item[starlightSuppressionSystems (list of dicts)] \hfill \\  List of dictionaries containing all supplied starlight suppression system attributes. Typically the first system will be used with the imager, and the second with the IFS. Only required attribute is `name'. See above for other commonly used attributes.
    \item[observingModes (list of dicts)] \hfill \\  List of dictionaries containing all mission observing modes. Only required attribute are `instName' and `systName'. See above for other commonly used attributes.
    \item[cachedir (string)] \hfill \\ Path to cache directory.
\end{description}
\end{itemize}

\subsubsection{get\_coro\_params Method}
For a given starlightSuppressionSystem, this method loads an input parameter from a table (fits file) or a scalar value. It then creates a callable lambda function, which depends on the wavelength of the system and the angular separation of the observed planet.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[syst (dict)] \hfill \\ Dictionary containing the parameters of one starlight suppression system
    \item[param\_name (string)] \hfill \\ Name of the parameter that must be loaded
    \item[fill (float)] \hfill \\ Fill value for working angles outside of the input array definition
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[syst (dict)] \hfill \\ Updated dictionary of parameters
\end{description}
\end{itemize}

\subsubsection{Cp\_Cb\_Csp Method} \label{sec:CpCbCsptask}
The \verb+Cp_Cb_Csp+ method calculates the electron count rates for planet signal, background noise, and speckle residuals.
\subsubsection*{Input}
\begin{itemize}
\item 
    \begin{description}
    \item[TL (TargetList module)] \hfill \\ TargetList class object, see \S\ref{sec:targetlist} for definition of available attributes
    \item[sInds (integer ndarray)] \hfill \\ Integer indices of the stars of interest
    \item[fZ (astropy Quantity array)] \hfill \\ Surface brightness of local zodiacal light in units of $ 1/arcsec^2 $
    \item[fEZ (astropy Quantity array)] \hfill \\ Surface brightness of exo-zodiacal light in units of $ 1/arcsec^2 $
    \item[dMag (float ndarray)] \hfill \\ Differences in magnitude between planets and their host star.
    \item[WA (astropy Quantity array)] \hfill \\ Working angles of the planets of interest in units of $arcsec$
    \item[mode (dict)] \hfill \\ Selected observing mode
    \item[returnExtra] \hfill \\ An optional flag that allows for additional rates to be returned to aid validation.
     \item[TK (TimeKeeping object)] \hfill \\ TimeKeeping object, see \S\ref{sec:timekeeping} for attributes (optional, defaults to None).
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[C\_p (astropy Quantity array)] \hfill \\ Planet signal electron count rate in units of $ 1/s $
    \item[C\_b (astropy Quantity array)] \hfill \\ Background noise electron count rate in units of $ 1/s $
    \item[C\_sp (astropy Quantity array)] \hfill \\ Residual speckle spatial structure (systematic error) in units of $ 1/s $
\end{description}
\end{itemize}

\subsubsection{calc\_intTime Method} \label{sec:calcintTimetask}
The \verb+calc_intTime+ method calculates the integration time required for specific planets of interest.  This method is called from the SurveySimulation module.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[TL (TargetList object)] \hfill \\ TargetList class object, see \S\ref{sec:targetlist} for definition of available attributes
    \item[sInds (integer ndarray)] \hfill \\ Integer indices of the stars of interest
    \item[fZ (astropy Quantity array)] \hfill \\ Surface brightness of local zodiacal light in units of $ 1/arcsec^2 $
    \item[fEZ (astropy Quantity array)] \hfill \\ Surface brightness of exo-zodiacal light in units of $ 1/arcsec^2 $
    \item[dMag (float ndarray)] \hfill \\ Differences in magnitude between planets and their host star.
    \item[WA (astropy Quantity array)] \hfill \\ Working angles of the planets of interest in units of $ arcsec $
    \item[mode (dict)] \hfill \\ Selected observing mode
    \item[TK (TimeKeeping object)] \hfill  \\ TimeKeeping object, see \S\ref{sec:timekeeping} for attributes (optional, defaults to None)
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[intTime (astropy Quantity array)] \hfill \\ Integration time for each of the planets of interest in units of $ day $
\end{description}
\end{itemize}

\subsubsection{calc\_minintTime Method} \label{sec:calcminintTimetask}
The \verb+calc_minintTime+ method calculates the minimum integration time for each star in the target list.  This method is called from the TargetList module.

\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[TL (TargetList module)] \hfill \\ TargetList class object, see \S\ref{sec:targetlist} for definition of available attributes
\end{description}
\end{itemize}

\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[minintTime (astropy Quantity array)] \hfill \\ Minimum integration time for each target star in units of $ day $
\end{description}
\end{itemize}

\subsubsection{calc\_dMag\_per\_intTime Method} \label{sec:calcdMagperintTime}
The \verb+calc_dMag_per_intTime+ method calculates the achievable planet delta magnitude (delta mag) for one integration time per star in the input list at one or more working angles.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[intTime (astropy Quantity array)] \hfill \\ Integration times in units of $ day $
    \item[TL (TargetList module)] \hfill \\ TargetList class object, see \S\ref{sec:targetlist} for definition of available attributes
    \item[sInds (integer ndarray)] \hfill \\ Integer indices of the stars of interest
    \item[fZ (astropy Quantity array)] \hfill \\ Surface brightness of local zodiacal light in units of $ 1/arcsec^2 $
    \item[fEZ (astropy Quantity array)] \hfill \\ Surface brightness of exo-zodiacal light in units of $ 1/arcsec^2 $
    \item[WA (astropy Quantity array)] \hfill \\ Working angles of the planets of interest in units of $ arcsec $
    \item[mode (dict)] \hfill \\ Selected observing mode
    \item[C\_b (astropy Quantity array)] \hfill \\ Background noise electron count rate in units of 1/s (optional, defaults to None)
    \item[C\_sp (astropy Quantity array)] \hfill \\ Residual speckle spatial structure (systematic error) in units of 1/s (optional, defaults to None)
    \item[TK (TimeKeeping module)] \hfill \\ TimeKeeping class object (see \ref{sec:timekeeping})
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[dMag (float ndarray)] \hfill \\ Achievable dMag for given integration time and working angle
\end{description}
\end{itemize}

\subsubsection{ddMag\_dt Method} \label{sec:ddMagdt}
The \verb+ddMag_dt+ method calculates the derivative of achievable dMag with respect to integration time.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[intTime (astropy Quantity array)] \hfill \\ Integration times in units of $ day $
    \item[TL (TargetList module)] \hfill \\ TargetList class object, see \S\ref{sec:targetlist} for definition of available attributes
    \item[sInds (integer ndarray)] \hfill \\ Integer indices of the stars of interest
    \item[fZ (astropy Quantity array)] \hfill \\ Surface brightness of local zodiacal light in units of $ 1/arcsec^2 $
    \item[fEZ (astropy Quantity array)] \hfill \\ Surface brightness of exo-zodiacal light in units of $ 1/arcsec^2 $
    \item[WA (astropy Quantity array)] \hfill \\ Working angles of the planets of interest in units of $ arcsec $
    \item[mode (dict)] \hfill \\ Selected observing mode
    \item[C\_b (astropy Quantity array)] \hfill \\ Background noise electron count rate in units of 1/s (optional, defaults to None)
    \item[C\_sp (astropy Quantity array)] \hfill \\ Residual speckle spatial structure (systematic error) in units of 1/s (optional, defaults to None)
    \item[TK (TimeKeeping module)] \hfill \\ TimeKeeping class object (see \ref{sec:timekeeping})
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[ddMagdt (astropy Quantity array)] \hfill \\ Derivative of achievable dMag with respect to integration time in units of $ 1/s $
\end{description}
\end{itemize}


\subsubsection{get\_param\_data} \label{sec:getparamdata}
Used to get data for interpolants that has been stored in a fits or csv file.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[pth (string)] \hfill \\ Path to the file location, can be a string or path object
    \item[left\_col\_name (string)] \hfill \\ Header of the column in the file that will be used as the independent variable
    \item[param\_name (string)] \hfill \\ Header of the column that will be used as the dependent variable
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[dat (ndarray)] \hfill \\ A two column numpy array with the data used to create the interpolant
\end{description}
\end{itemize}
% ZODIACAL LIGHT 

\subsection{Zodiacal Light}\label{sec:zodiacallight}
The Zodiacal Light module contains methods to calculate the zodiacal light surface brightness of local Zodi, extrasolar Zodi, star specific minimum Zodi, and star specific maximum Zodi.
%The input and output of the Zodiacal Light methods are depicted in \reffig{fig:zodiacallightmodule}. The Zodiacal Light module contains 5 methods:
\begin{itemize}[leftmargin=1in,font={\ttfamily}]
    \item[\texttt fZ] Calculates the surface brightness of local zodiacal light  (see \S\ref{sec:fZtask})
    \item[\texttt fEZ] Calculates the surface brightness of exozodiacal light (see \S\ref{sec:fEZtask})
    \item[\texttt generate\_fZ] Calculates the fZ for each star in TL for 1 year (see \S\ref{sec:generatefZtask})
    \item[\texttt calcfZmax] Calculates the maximum fZ excluding keepout regions (see \S\ref{sec:calcfZmaxtask})
    \item[\texttt calcfZmin] Calculates the minimum fZ (see \S\ref{sec:calcfZmintask})
    \item[\texttt gen\_systemnEZ] Calculates the number of exo-zodi (see \S\ref{sec:exozoditask})
    \item[\texttt extractfZmin\_fZQuads] Extracts global minimum local zodiacal light intensity
\end{itemize}

\begin{figure}[ht]
    \begin{center}
        \begin{tabular}{c}
             \includegraphics[width=0.8\textwidth]{ZodiTasks2}
        \end{tabular}
    \end{center}
    \caption{\label{fig:zodiacallightmodule} Depiction of Zodiacal Light module methods including input and output (see \S\ref{sec:fZtask} and \S\ref{sec:fEZtask}).}
\end{figure}

\subsubsection{Zodiacal Light Object Attribute Initialization}

\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[magZ (float)] \hfill \\ Zodiacal light brightness magnitude (per $ arcsec^2 $). Defaults to 23.
    \item[magEZ (float)] \hfill \\ Exo-zodiacal light brightness magnitude (per $ arcsec^2 $). Defaults to 22.
    \item[varEZ (float)] \hfill \\ Exo-zodiacal light variation (variance of log-normal distribution). Defaults to 0 (constant exo-zodiacal light).
    \item[cachedir (string)] \hfill \\ String indicating the directory to look for and cache files in.
    \item[commonSystemfEZ (boolean)] \hfill \\ A boolean indicating whether each star has a common number of Exozodi 
\end{description}
\end{itemize}

\subsubsection*{Attributes}
\begin{itemize}
\item
\begin{description}
    \item[magZ (float)] \hfill \\ Zodi brightness magnitude (per $ arcsec^2 $)
    \item[magEZ (float)] \hfill \\ Exo-zodi brightness magnitude (per $ arcsec^2 $)
    \item[varEZ (float)] \hfill \\ Exo-zodiacal light variation (variance of log-normal distribution)
    \item[fZ0 (astropy Quantity)] \hfill \\ Default surface brightness of zodiacal light in units of $ 1/arcsec^2 $ 
    \item[fEZ0 (astropy Quantity)] \hfill \\ Default surface brightness of exo-zodiacal light in units of $ 1/arcsec^2 $ 
    \item[cachedir (string)] \hfill \\ Path to cache directory
    \item[nEZ (list)] \hfill \\ a list of number of exo-zodi
\end{description}
\end{itemize}

\subsubsection{fZ Method} \label{sec:fZtask}
The \verb+fZ+ method returns surface brightness of local zodiacal light for planetary systems.  This functionality is used by the Simulated Universe module.

\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[Obs (Observatory module)] \hfill \\ Observatory class object, see \S\ref{sec:observatory} for description of functionality and attributes       
    \item[TL (TargetList module)] \hfill \\ TargetList class object, see \S\ref{sec:targetlist} for description of functionality and attributes       
    \item[sInds (integer ndarray)] \hfill \\ Integer indices of the stars of interest
    \item[currentTime (astropy \href{http://astropy.readthedocs.org/en/latest/time/index.html}{Time} array)] \hfill \\ Current absolute mission time in MJD    
    \item[mode (dict)] \hfill \\ Selected observing mode
\end{description}
\end{itemize}

\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[fZ (astropy Quantity array)] \hfill \\ Surface brightness of zodiacal light in units of $ 1/arcsec^2 $
\end{description}
\end{itemize}

\subsubsection{fEZ Method} \label{sec:fEZtask}
The \verb+fEZ+ method returns surface brightness of exo-zodiacal light for planetary systems.  This functionality is used by the Simulated Universe module.

\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[MV (integer ndarray)] \hfill \\ Apparent magnitude of the star (in the V band)
    \item[I (astropy Quantity array)] \hfill \\ Inclination of the planets of interest in units of $ deg $
    \item[d (astropy Quantity n$\times$3 array)] \hfill \\ Distance to star of the planets of interest in units of $AU$
\end{description}
\end{itemize}

\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[fEZ (astropy Quantity array)] \hfill \\ Surface brightness of exo-zodiacal light in units of $ 1/arcsec^2 $
\end{description}
\end{itemize}

\subsubsection{gen\_systemnEZ Method} \label{sec:exozoditask}
The \verb+gen\_systemfEZ+ method returns the number of exo-zodi to use in the \verb+fEZ+ method. This function is used by the Simulated Universe module to generate nEZ for each star.

\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[nStars (integer)] \hfill \\ Number of exo-zodi to generate
\end{description}
\end{itemize}

\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[nEZ (ndarray)] \hfill \\ An array of integers representing exozodis
\end{description}
\end{itemize}

\subsubsection{generate\_fZ Method} \label{sec:generatefZtask}
Calculates fZ values for each star over an entire earth orbit of the sun. This function is ONLY called by calcfZmax or calcfZmin functions. This method caches data to .starkfZ files. The output is a 2d astropy quantity array containing zodiacal light surface brightness for each star at 1000 points evenly distributed over 1 year. This method is not called by prototype modules.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[Obs (Observatory module)] \hfill \\ Observatory class object
    \item[TL (TargetList module)] \hfill \\ TargetList class object
    \item[currentTimeAbs (astropy \href{http://astropy.readthedocs.org/en/latest/time/index.html}{Time})] \hfill \\ Current absolute mission time in $ MJD $
    \item[mode (dict)] \hfill \\ Selected observing mode
    \item[hashname (string)] \hfill \\ String describing the mission specific json file
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[fZ [resolution, sInds]] \hfill \\ where fZ is the zodiacal light for each star and sInds are the indicies to generate fZ for
\end{description}
\end{itemize}

\subsubsection{calcfZmax Method} \label{sec:calcfZmaxtask}
Finds the value and time of maximum zodiacal light for each star over an entire orbit of the sun not including keeoput angles. The prototype returns a constant fZ and the current absolute time.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[sInds [sInds]] \hfill \\ the star indices we would like fZmax and fZmaxInds returned for
    \item[Obs (Observatory module)] \hfill \\ Observatory class object
    \item[TL (TargetList module)] \hfill \\ TargetList class object
    \item[currentTimeAbs (astropy \href{http://astropy.readthedocs.org/en/latest/time/index.html}{Time})] \hfill \\ Current absolute mission time in $ MJD $
    \item[mode (dict)] \hfill \\ Selected observing mode
    \item[hashname (string)] \hfill \\ String describing the mission specific json file
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[valfZmax [astropy Quantity array]] \hfill \\ maximum value of fZ for each star specified by sInds with units of 1/arcsec$^2$
    \item[absTimefZmax [astropy Time array]] \hfill \\ absolute time fZmax occurs for each star specified by sInds
    %\item[fZmaxInds [sInds]] \hfill \\ the indices as a part of 1000 where the fZmaxInd occurs
\end{description}
\end{itemize}

\subsubsection{calcfZmin Method} \label{sec:calcfZmintask}
Finds the minimum zodiacal light values for each star over an entire earth orbit of the sun. The prototype implementation returns a constant fZ and the current absolute time.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[sInds [sInds]] \hfill \\ the star indices we would like fZmin and fZminInds returned for
    \item[Obs (Observatory module)] \hfill \\ Observatory class object
    \item[TL (TargetList module)] \hfill \\ TargetList class object
    \item[currentTimeAbs (astropy \href{http://astropy.readthedocs.org/en/latest/time/index.html}{Time})] \hfill \\ Current absolute mission time in $ MJD $
    \item[mode (dict)] \hfill \\ Selected observing mode
    \item[hashname (string)] \hfill \\ String describing the mission specific json file
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[valfZmin [astropy Quantity array]] \hfill \\ minimum value of fZ for each star specified by sInds with units of arcsec$^{-2}$
    \item[absTimefZmin [astropy Time array]] \hfill \\ absolute time fZmin occurs for each star specified by sInds
    %\item[fZminInds [sInds]] \hfill \\ the indices as a part of 1000 where the fZminInd occurs
\end{description}
\end{itemize}

\subsubsection{extractfZmin\_fZQuads Method} \label{sec:extractfZmin_fZQuadstask}
Finds the minimum zodiacal light values for each star over an entire earth orbit of the sun. The prototype implementation returns a constant fZ and the current absolute time.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[fZQuads (list)] \hfill \\ A list with shape [sInds][Number fZmin][4]
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[valfZmin [astropy Quantity array]] \hfill \\ minimum value of fZ for each star specified by sInds with units of arcsec$^{-2}$
    \item[absTimefZmin [astropy Time array]] \hfill \\ absolute time fZmin occurs for each star specified by sInds
\end{description}
\end{itemize}


% BACKGROUND SOURCES

\subsection{Background Sources}\label{sec:backgroundsources}

The Background Sources module provides density of background sources for a given target based on its coordinates and the integration depth. The integration depth is the limiting planet magnitude, that is the magnitude of the faintest planet we can observe. This will be used in the post-processing module to determine false alarms based on confusion.  The prototype module has no inputs, the attribute \texttt{cachedir} (path to the cache directory), and only a single function: \verb+dNbackground+ (see \S\ref{sec:dNbackgroundtask}).

\subsubsection{dNbackground Method} \label{sec:dNbackgroundtask}
Returns background source number densities
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[coords (astropy SkyCoord array)] \hfill \\ \href{http://astropy.readthedocs.org/en/latest/api/astropy.coordinates.SkyCoord.html}{SkyCoord object} containing right ascension, declination, and  distance to star of the planets of interest in units of $ deg $, $ deg $ and $ pc $.
    \item[intDepths (float ndarray)] \hfill \\ Integration depths equal to the planet magnitude (Vmag+dMag), i.e. the V magnitude of the dark hole to be produced for each target. Must be of same length as coords.
\end{description}
\end{itemize}

\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[dN (astropy Quantity array)] \hfill \\ Number densities of background sources for given targets in  units of $ 1/arcmin^2 $. Same length as inputs.
\end{description}
\end{itemize}


% POST-PROCESSING

\subsection{Post-Processing}\label{sec:postprocessing}
The Post-Processing module encodes the effects of post-processing on the data gathered in a simulated observation, and the effects on the final contrast of the simulation.  The Post-Processing module is also responsible for determining whether a planet detection has occurred for a given observation, returning one of four possible states---true positive (real detection), false positive (false alarm), true negative (no detection when no planet is present) and false negative (missed detection).  These can be generated based solely on statistical modeling or by processing simulated images.

The Post-Processing module contains the \verb+det_occur+ method (see \S\ref{sec:detoccurtask}).  This method determines if a planet detection occurs for a given observation.  The input and output of this method are depicted in \reffig{fig:postprocessingmodule}.

\begin{figure}[ht]
    \begin{center}
        \begin{tabular}{c}
            \includegraphics[width=0.8\textwidth]{PostProcessing2}
        \end{tabular}
    \end{center}
    \caption{\label{fig:postprocessingmodule} Depiction of Post-Processing module method including input and output (see \S\ref{sec:detoccurtask}).}
\end{figure}

\subsubsection{Post-Processing Object Attribute Initialization}

\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[FAP (float)] \hfill \\ Detection false alarm probability. Default value is $3 \times 10^{-7}$.
    \item[MDP (float)] \hfill \\ Missed detection probability. Default value is $10^{-3}$.
    \item[ppFact (float, callable)] \hfill \\ Post-processing contrast factor, between 0 and 1: either a scalar for constant gain, or a two-column array for separation-dependent gain, where the first column contains the angular separation in units of $arcsec$. May be data or FITS filename. Default value is 1.
    \item[FAdMag0 (float, callable)] \hfill \\ Minimum delta magnitude that can be obtained by a false alarm: either a scalar for constant dMag, or a two-column array for separation-dependent dMag, where the first column contains the angular separation in units of arcsec. May be data or FITS filename. Default value is 15.
\end{description}
\end{itemize}

\subsubsection*{Attributes}
\begin{itemize}
\item 
\begin{description}
    \item[BackgroundSources (BackgroundSources module)] \hfill \\
        BackgroundSources class object (see \ref{sec:backgroundsources})
    \item[FAP (float)] \hfill \\ Detection false alarm probability
    \item[MDP (float)] \hfill \\ Missed detection probability
    \item[ppFact (float, callable)] \hfill \\ Post-processing contrast factor, between 0 and 1.
    \item[FAdMag0 (float, callable)] \hfill \\ Minimum delta magnitude that can be obtained by a false alarm.
    \item[cachedir (string)] \hfill \\ Path to cache directory
\end{description}
\end{itemize}

\subsubsection{det\_occur Method} \label{sec:detoccurtask}
The \verb+det_occur+ method determines if a planet detection has occurred.

\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[SNR (float ndarray)] \hfill \\ Signal-to-noise ratio of the planets around the selected target
    \item[mode (dict)] \hfill \\ Selected observing mode
    \item[TL (TargetList module)] \hfill \\ TargetList class object
    \item[sInd (integer)] \hfill \\ Index of the star being observed
    \item[intTime (astropy Quantity)] \hfill \\ Selected star integration time for detection
\end{description}
\end{itemize}

\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[FA (boolean)] \hfill \\ False alarm (false positive) boolean.
    \item[MD (boolean ndarray)] \hfill \\ Missed detection (false negative) boolean with the size of number of planets around the target.
\end{description}
\end{itemize}


% COMPLETENESS

\subsection{Completeness}\label{sec:completeness}
The Completeness module takes in information from the Planet Population module to determine initial completeness and update completeness values for target list stars when called upon.

The Completeness module contains the following methods:
\begin{itemize}[leftmargin=2in,font={\ttfamily}]
    \item[\texttt target\_completeness] Generates initial completeness values for each star in the target list (see \S\ref{sec:targetcompletenesstask})
    \item[\texttt gen\_update] generates dynamic completeness values for successive observations of each star in the target list  (see \S\ref{sec:genupdatetask})
    \item[\texttt completeness\_update] Updates the completeness values following an observation (see \S\ref{sec:completenessupdatetask})
    \item[\texttt comp\_per\_intTime] Calculates completeness values per integration time (see \S\ref{sec:compperintTime}) 
    \item[\texttt dcomp\_dt] Calculates derivative of completeness with respect to integration time (see \S\ref{sec:dcompdt})
\end{itemize}

\subsubsection{Completeness Object Attribute Initialization}

\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[dMagLim (float)] \hfill \\ Limiting planet-to-star delta magnitude for completeness. Defaults to 25.
    \item[minComp (float)] \hfill \\ Minimum completeness value for inclusion in target list.  Defaults to 0.1.
\end{description}
\end{itemize}
Monte Carlo methods for calculating completeness will require an input of the number of planet samples called \verb+Nplanets+. 

\subsubsection*{Attributes}
\begin{itemize}
\item 
\begin{description}
    \item[PlanetPopulation (PlanetPopulation module)] \hfill \\ PlanetPopulation object (see \ref{sec:planetpopulation})
    \item[PlanetPhysicalModel (PlanetPhysicalModel module)] \hfill \\ PlanetPhysicalModel module object (see \ref{sec:planetphysicalmodel}) 
    \item[dMagLim (float)] \hfill \\ Limiting planet-to-star delta magnitude for completeness
    \item[minComp (float)] \hfill \\ Minimum completeness value for inclusion in target list
    \item[cachedir (string)] \hfill \\ Path to cache directory
\end{description}
\end{itemize}

\subsubsection{target\_completeness Method}
\label{sec:targetcompletenesstask}
The \verb+target_completeness+ method generates completeness values for each star in the target list.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[TL (TargetList module)] \hfill \\ TargetList class object, see \S\ref{sec:targetlist} for definition of functionality and attributes
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[comp0 (float ndarray)] \hfill \\ Contains completeness values for each star in the target list
\end{description}
\end{itemize}

\subsubsection{gen\_update Method} \label{sec:genupdatetask}
The \verb+gen_update+ method generates dynamic completeness values for successive observations of each star in the target list.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[TL (TargetList module)] \hfill \\ TargetList class object, see \S\ref{sec:targetlist} for definition of functionality and attributes
\end{description}
\end{itemize}
\subsubsection*{Attributes Updated}
\begin{itemize}
\item
\begin{description}
    \item[updates (float ndarray)] \hfill \\ genrates completeness update array necessary for dynamic completeness calculations
\end{description}
\end{itemize}

\subsubsection{completeness\_update Method}\label{sec:completenessupdatetask}
The \verb+completeness_update+ method updates the completeness values for each star in the target list following an observation.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[TL (TargetList module)] \hfill \\ TargetList class object, see \S\ref{sec:targetlist} for definition of functionality and attributes
    \item[sInds (integer array)] \hfill \\ Indices of stars to update
    \item[visits (integer array)] \hfill \\ Number of visits for each star
    \item[dt (astropy Quantity array)] \hfill \\ Time since previous observation
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[comp0 (float ndarray)] \hfill \\
        Updated completeness values for each star in the target list
\end{description}
\end{itemize}

\subsubsection{revise\_update}
Keeps completeness update values only for targets remaining in target list during filtering (called from TargetList.filter\_target\_list)
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[ind (ndarray)] \hfill \\ 1D numpy ndarray of indices to keep
\end{description}
\end{itemize}
\subsubsection*{Attributes Updated}
\begin{itemize}
\item
\begin{description}
    \item[updates (float ndarray)] \hfill \\ stores completeness update values only for targets of interest
\end{description}
\end{itemize}

\subsubsection{comp\_per\_intTime Method}\label{sec:compperintTime}
The \verb+comp_per_intTime+ method calculates the completeness values per integration time.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[intTime (astropy Quantity array)] \hfill \\ Integration times in units of $ day $
    \item[TL (TargetList module)] \hfill \\ TargetList class object, see \S\ref{sec:targetlist} for definition of available attributes
    \item[sInds (integer ndarray)] \hfill \\ Integer indices of the stars of interest
    \item[fZ (astropy Quantity array)] \hfill \\ Surface brightness of local zodiacal light in units of $ 1/arcsec^2 $
    \item[fEZ (astropy Quantity array)] \hfill \\ Surface brightness of exo-zodiacal light in units of $ 1/arcsec^2 $
    \item[WA (astropy Quantity array)] \hfill \\ Working angles of the planets of interest in units of $ arcsec $
    \item[mode (dict)] \hfill \\ Selected observing mode
    \item[TK (TimeKeeping module)] \hfill \\ TimeKeeping class object (see \ref{sec:timekeeping})
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[comp (float ndarray)] \hfill \\
        Completeness values
\end{description}
\end{itemize}

\subsubsection{dcomp\_dt Method}
\label{sec:dcompdt}
The \verb+dcomp_dt+ method calculates the derivative of completeness with respect to integration time.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[intTime (astropy Quantity array)] \hfill \\ Integration times in units of $ day $
    \item[TL (TargetList module)] \hfill \\ TargetList class object, see \S\ref{sec:targetlist} for definition of available attributes
    \item[sInds (integer ndarray)] \hfill \\ Integer indices of the stars of interest
    \item[fZ (astropy Quantity array)] \hfill \\ Surface brightness of local zodiacal light in units of $ 1/arcsec^2 $
    \item[fEZ (astropy Quantity array)] \hfill \\ Surface brightness of exo-zodiacal light in units of $ 1/arcsec^2 $
    \item[WA (astropy Quantity array)] \hfill \\ Working angles of the planets of interest in units of $ arcsec $
    \item[mode (dict)] \hfill \\ Selected observing mode
    \item[TK (TimeKeeping module)] \hfill \\ TimeKeeping class object (see \ref{sec:timekeeping})
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[dcomp (float ndarray)] \hfill \\
        Derivative of completeness with respect to integration time
\end{description}
\end{itemize}

% TARGET LIST

\subsection{Target List}
The Target List module takes in information from the Star Catalog, Optical System, Zodiacal Light, Post Processing, Background Sources, Completeness, PlanetPopulation, and Planet Physical Model modules to generate the target list for the simulated survey.  This list can either contain all of the targets where a planet with specified parameter ranges could be observed or a list of pre-determined targets such as in the case of a mission which only seeks to observe stars where planets are known to exist from previous surveys.  The final target list encodes all of the same information as is provided by the Star Catalog module.

The TargetList module contains the following methods:
\begin{itemize}[leftmargin=2in,font={\ttfamily}]
    \item[\texttt populate\_target\_list] Populates values from the star catalog, and updates relevant TargetList attributes (see \S\ref{sec:populatetargetlisttask})
    \item[\texttt fillPhotometryVals] Fills in missing photometric values
    \item[\texttt filter\_target\_list] Filters the target list by any required metrics (see \S\ref{sec:filtertargetlisttask} and \S\ref{sec:filteringhelpertask})
    %\item[\texttt nan_filter] Populates Target List and filters out values which are nan
    %\item[\texttt binary_filter] Removes stars which have attribute Binary\_cut == True
    %\item[\texttt life_expectancy_filter] Removes stars from TargetList which have BV < 0.3
    %\item[\texttt main_sequence_filter] Removes stars from Target List which are not main sequence
    %\item[\texttt fgk_filter] Includes only F, G, K spectral type stars in Target List
    %\item[\texttt vis_mag_filter] Includes stars which are below the maximum apparent visual magnitude
    %\item[\texttt outside_IWA_filter] Includes stars with planets with orbits outside of the IWA 
    %\item[\texttt max_dmag_filter] Includes stars if maximum delta mag is in the allowed orbital range
    %\item[\texttt int_cutoff_filter] Includes stars if calculated minimum integration time is less than cutoff
    %\item[\texttt completeness_filter] Includes stars if completeness is larger than the minimum value
    %\item[\texttt revise_lists] Replaces Target List catalog attributes with filtered values and updates the number of target stars.
    \item[\texttt stellar\_mass] Populates target list with 'true' and 'approximate' stellar masses
    \item[\texttt starprop] Finds target star positions vector (see \S\ref{sec:starproptask})
    \item[\texttt starMag] Calculates star visual magnitudes with B-V color (see \S\ref{sec:starMagtask})
    \item[\texttt stellarTeff] Calculates the effective stellar temperature based on B-V color (see \S\ref{sec:stellarTefftask})
    \item[\texttt radiusFromMass] Estimates star radius from mass
    \item[\texttt gen\_inclinations] Randomly generates star system inclinations
    \item[\texttt dump\_catalog] Dumps the target list star properties
    \item[\texttt constructIPACurl] Queries IPAC exoplanet archive for known planet data 
    \item[\texttt setOfStarsWithKnownPlanets] Finds set of stars with known planets
    \item[\texttt loadAliasFile] Loads the star name aliases from the alias pickle file in the util folder
    \item[\texttt createKnownPlanetBoolean] Calculates booleans indicating stars with known planets 
\end{itemize}

\label{sec:targetlist}
\subsubsection{Target List Object Attribute Initialization}

\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[staticStars (boolean)] \hfill \\ Boolean used to force static target positions set at mission start time.
    \item[keepStarCatalog (boolean)] \hfill \\ Boolean representing whether to delete the star catalog object after the target list is assembled (defaults to False).  If True, object reference will be available from TargetList class object.
    %\item[fillPhotometry (boolean)] \hfill \\ 
    %\item[explainFiltering (boolean)] \hfill \\
    %\item[filterBinaries (boolean)] \hfill \\
    \item[filterSubM (boolean)] \hfill \\ Defaults False. If true, removes all sub-M spectral types (L,T,Y). Note that fillPhotometry will typically fail for any stars of this type, so this should be set to True when fillPhotometry is True.
    \item[cachedir (string)] \hfill \\ Path to cache directory.
    \item[filter\_for\_char (boolean)] \hfill \\ TODO
    \item[earths\_only (boolean)] \hfill \\ TODO
    \item[getKnownPlanets (boolean)] \hfill \\ A boolean indicating whether to grab the list of known planets from IPAC and read the alias pkl file.
\end{description}
\end{itemize}

\subsubsection*{Attributes}
\begin{itemize}
\item 
\begin{description}
    \item[(StarCatalog values)] \hfill \\ Mission specific filtered star catalog values from StarCatalog class object (see \ref{sec:starcatalog})
    \item[StarCatalog (StarCatalog module)]\hfill \\ StarCatalog class object (only retained if keepStarCatalog is True, see \ref{sec:starcatalog})
    \item[PlanetPopulation (PlanetPopulation module)] \hfill \\ PlanetPopulation class object (see \ref{sec:planetpopulation})
    \item[PlanetPhysicalModel (PlanetPhysicalModel module)] \hfill \\ PlanetPhysicalModel class object (see \ref{sec:planetphysicalmodel})
    \item[OpticalSystem (OpticalSystem module)] \hfill \\ OpticalSystem class object (see \ref{sec:opticalsystem})
    \item[ZodiacalLight (ZodiacalLight module)] \hfill \\ ZodiacalLight class object (see \ref{sec:zodiacallight})
    \item[BackgroundSources (BackgroundSources module)] \hfill \\ BackgroundSources class object (see \ref{sec:backgroundsources})
    \item[PostProcessing (PostProcessing module)] \hfill \\ PostProcessing class object (see \ref{sec:postprocessing})
    \item[Completeness (Completeness module)] \hfill \\ Completeness class object (see \ref{sec:completeness})
    \item[tint0 (astropy Quantity array)] \hfill \\ Minimum integration time for each target star. Calculated from \verb+OpticalSystem.calc_minintTime+ \S\ref{sec:calcminintTimetask}
    \item[comp0 (float ndarray)] \hfill \\ Completeness value for each target star. Calculated from \verb+Completeness.target_completeness+ \S\ref{sec:targetcompletenesstask}
    \item[MsEst (float ndarray)] \hfill \\ Approximate stellar mass in $ M_{sun} $
    \item[MsTrue (float ndarray)] \hfill \\ Stellar mass with an error component included in $ M_{sun} $
    \item[nStars (int)] \hfill \\ Number of target stars
    \item[cachedir (string)] \hfill \\ Path to cache directory
    \item[I (list)] \hfill \\ A list of inclinations generated in the Simulate Universe gen\_physical\_properties method
\end{description}
\end{itemize}

\subsubsection{populate\_target\_list Method} \label{sec:populatetargetlisttask}
The \verb+populate_target_list+ method is responsible for populating values from the star catalog  (or any other source) into the target list attributes. It has not specific inputs and outputs, but is always passed the full specification dictionary, and updates all relevant Target List attributes.  This method is called from the prototype constructor, and does not need to be called from the implementation constructor when overloaded in the implementation.   The prototype implementation copies values directly from star catalog and removes stars with any NaN attributes. It also calls the \verb+target_completeness+ in the Completeness module (\S\ref{sec:targetcompletenesstask}) and the \verb+calc_minintTime+ in the Optical System module (\S\ref{sec:calcminintTimetask}) to generate the initial completeness and minimum integration time for all targets.  It also generates 'true' and 'approximate' star masses using object method \verb+stellar_mass+ (see below).
\subsubsection*{Update Attributes}
\begin{itemize}
\item
\begin{description}
    \item[nStars (integer)] \hfill \\ number of target stars
    \item[comp0 (float ndarray)] \hfill \\ Completeness values for each target star
    \item[tint0 (astropy Quantity array)] \hfill \\ Minimum integration times for target list stars in units of day
\end{description}
\end{itemize}

\subsubsection{filter\_target\_list Method}  \label{sec:filtertargetlisttask}
The \verb+filter_target_list+ method is responsible for filtering the targetlist to produce the values from the star catalog  (or any other source) into the target list attributes. It has not specific inputs and outputs, but is always passed the full specification dictionary, and updates all relevant Target List attributes.  This method is called from the prototype constructor, immediately after the \verb+populate_target_list+ call, and does not need to be called from the implementation constructor when overloaded in the implementation.   The prototype implementation filters out any targets where the widest separation planet in the modeled population would be inside the system IWA, any targets where the minimum integration time for favorable planet delta magnitude and instrument working angle is above the specified integration time cutoff, and all targets where the initial completeness is below the specified threshold. 

\subsubsection{Target List Filtering Helper Methods} \label{sec:filteringhelpertask}
The \verb+filter_target_list+ method calls multiple helper functions to perform the actual filtering tasks.  Additional filters can be defined in specific implementations and by overloading the  \verb+filter_target_list+ method.  The filter subtasks (with a few exception) take no inputs and operate directly on object attributes. The prototype TargetList module calls the following methods to remove the corresponding stars:
\begin{itemize}[leftmargin=2in,font={\ttfamily}]
    \item[\texttt nan\_filter] Stars with NAN values in their parameters
    \item[\texttt binary\_filter] Binary stars
    \item[\texttt outside\_IWA\_filter] Systems with planets inside the OpticalSystem fundamental IWA
    \item[\texttt int\_cutoff\_filter] Systems where minimum integration time is longer than OpticalSystem cutoff
    \item[\texttt completeness\_filter] Systems not meeting the Completeness threshold
    \item[\texttt max\_dmag\_filter] Filters out all targets with minimum delta mag above the limiting delta mag (from input spec)
    \item[\texttt main\_sequence\_filter] Filters any target lists that are not on the Main Sequence (estimated from the MV and BV attributes)
    \item[\texttt fgk\_filter] Filters any targets that are not F, G, or K stars
    \item[\texttt vis\_mag\_filter] Filters out targets with visible magnitudes below input value \verb+Vmagcrit+
    \item[\texttt revise\_lists] General helper function for applying filters
    \item[\texttt life\_expectancy\_filter] Filters stars which have BV < 0.3
\end{itemize}

\subsubsection{stellar\_mass Method} \label{sec:stellarmasstask}
This method calculates stellar mass via the formula relating absolute V magnitude and stellar mass.  The values are in units of solar mass.
\subsubsection*{Update Attributes}
\begin{itemize}
\item
\begin{description}
    \item[MsEst (float ndarray)] \hfill \\ approximate stellar masses
    \item[MsTrue (float ndarray)] \hfill \\ stellar mass combined with random error
\end{description}
\end{itemize}

\subsubsection{starprop Method} \label{sec:starproptask}
The \verb+starprop+ method finds target star positions vector in heliocentric equatorial (default) or ecliptic frame for current time $MJD$.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[sInds (integer ndarray)] \hfill \\ Indices of the stars of interest
    \item[currentTime (astropy \href{http://astropy.readthedocs.org/en/latest/time/index.html}{Time} array)] \hfill \\ Current absolute mission time in MJD
    \item[eclip (boolean)] \hfill \\ Boolean used to switch to heliocentric ecliptic frame. Defaults to False, corresponding to heliocentric equatorial frame.
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[r\_targ (astropy Quantity $n\times3$ array)] \hfill \\ Target star positions vector in heliocentric equatorial (default) or ecliptic frame in units of $pc$
\end{description}
\end{itemize}

\subsubsection{starMag Method} \label{sec:starMagtask}
The \verb+starMag+ method calculates star visual magnitudes with B-V color using empirical fit to data from Pecaut and Mamajek (2013, Appendix C). The expression for flux is accurate to about $7\%$, in the range of validity 400 $ nm < \lambda < $ 1000 $ nm $ (Traub et al. 2016).
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[sInds (integer ndarray)] \hfill \\ Indices of the stars of interest
    \item[lam (astropy Quantity)] \hfill \\ Wavelength in units of $ nm $
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[mV (float ndarray)] \hfill \\ Star visual magnitudes with B-V color
\end{description}
\end{itemize}

\subsubsection{stellarTeff Method} \label{sec:stellarTefftask}
The \verb+stellarTeff+ method calculates the effective stellar temperature based on B-V color.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[sInds (integer ndarray)] \hfill \\ Indices of the stars of interest
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[mV (float ndarray)] \hfill \\ Star visual magnitudes with B-V color
\end{description}
\end{itemize}

\subsubsection{radiusFromMass Method} \label{sec:radiusFromMasstask}
The \verb+radiusFromMass+ method estimates the stellar radius from the stellar mass.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[sInds (integer ndarray)] \hfill \\ Indices of the stars of interest
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[starRadius (float ndarray)] \hfill \\ Star radii in sun radius units
\end{description}
\end{itemize}

\subsubsection{gen\_inclinations Method} \label{sec:gen_inclinationstask}
The \verb+gen\_inclinations+ method randomly generates star system inclinations using the given Irange.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[Irange (float ndarray)] \hfill \\ The range to generate inclinations over
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[I (float ndarray)] \hfill \\ Star system inclinations in degrees
\end{description}
\end{itemize}

\subsubsection{dump\_catalog Method} \label{sec:dump_catalogtask}
The \verb+dump\_catalog+ method dumps all star attributes into a dictionary for output.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[None] \hfill \\
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[catalog (dictionary)] \hfill \\ Dictionary of star catalog properties
\end{description}
\end{itemize}

\subsubsection{constructIPACurl Method} \label{sec:constructIPACurltask}
The \verb+constructIPACurl+ method constructs a url and queries the IPAC exoplanet archive for the known exoplanet data.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[tableInput (string)] \hfill \\ a string indicating which table to reference. Default=``exoplanets''.
    \item[columnsInputList (list)] \hfill \\ List of strings indicating column headers to query.
    \item[formatInput (string)] \hfill \\ Format of the input. Default=``json''.
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[data (dictionary)] \hfill \\ A dictionary of exoplanet properties
\end{description}
\end{itemize}

\subsubsection{setOfStarsWithKnownPlanets Method} \label{sec:setOfStarsWithKnownPlanetstask}
The \verb+setOfStarsWithKnownPlanets+ method finds the set of star names with known planets.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[data (dictionary)] \hfill \\ A dictionary of exoplanet properties
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[list (list)] \hfill \\ A list of names of stars with known exoplanets around them.
\end{description}
\end{itemize}

\subsubsection{loadAliasFile Method} \label{sec:loadAliasFiletask}
The \verb+loadAliasFile+ method loads the alias file in the EXOSIMS util folder containing different star name aliases for stars.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[None] \hfill \\
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[list (list)] \hfill \\ A list of star aliases.
\end{description}
\end{itemize}

\subsubsection{createKnownPlanetBoolean Method} \label{sec:createKnownPlanetBooleantask}
The \verb+createKnownPlanetBoolean+ method creates a numpy array of booleans the length of nStars indicating whether that star has a known planet around it.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[alias (list)] \hfill \\ A list of star name aliases
    \item[starsWithPlanets (list)] \hfill \\ A list of stars with known planets
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[knownPlanetBoolean (ndarray)] \hfill \\ Boolean array indicating whether each star in the set of all stars with length nStars has a planet around them
\end{description}
\end{itemize}

\subsubsection{F0} \label{sec:F0}
This function calculates the spectral flux density for a given spectral type. It assumes that the Pickles Atlas is saved to TargetList. If a spectral type is provided it tries to match based on the luminosity class and then spectral type. If there is no type or match it tries to fit based on Traub et al. 2016 (JATIS).
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[BW (float)] \hfill \\ Bandwidth fraction
    \item[lam (astropy Quantity)] \hfill \\ central wavelength in units of $nm$
    \item[Spec (spectral type string)] \hfill \\ Should be something like G0V
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[F0 (astropy Quantity)] \hfill \\ The spectral flux density in uits of $ph/m**2/s/nm$
\end{description}
\end{itemize}

\subsubsection{starF0} \label{sec:starF0}
This returns the spectral flux density for all requested stars for the given observing mode. It caches results for faster access on subsequent calls.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[sInds (integer ndarray)] \hfill \\ Indices of the stars of interest
    \item[mode (dict)] \hfill \\ Observing mode dictionary
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[F0 (astropy Quantity array)] \hfill \\ Array of spectral flux density in units of $ph/m**2/s/nm$
\end{description}
\end{itemize}


% SIMULATED UNIVERSE 

\subsection{Simulated Universe} \label{sec:simulateduniverse}
The Simulated Universe module instantiates the Target List module and creates a synthetic universe by populating planetary systems about some or all of the stars in the target list.  For each target, a planetary system is generated based on the statistics encoded in the Planet Population module, so that the overall planet occurrence and multiplicity rates are consistent with the provided distribution functions.  Physical parameters for each planet are similarly sampled from the input density functions (or calculated via the Planet physical model).  All planetary orbital and physical parameters are encoded as arrays of values, with an indexing array (pInds) that maps planets to the stars in the target list. 

All planetary parameters are generated in the constructor via calls to the appropriate value generating functions in the planet population module.%The input and updated attributes of the Simulated Universe methods are depicted in \reffig{fig:simulateduniversemodule}. 
The Simulated Universe module contains the following methods: 

\begin{itemize}[leftmargin=2in,font={\ttfamily}]
    \item[\texttt gen\_physical\_properties] Populates the orbital elements and physical characteristics of all planets (see \S\ref{sec:genphysicalpropertiestask})
    \item[\texttt gen\_M0] Finds initial mean anomaly for each planet (see \S\ref{sec:genM0task})
    \item[\texttt init\_systems] Finds initial time-dependant parameters such as position and velocity vectors, along with exo-zodiacal surface brightness, delta magnitude, and working angle (see \S\ref{sec:initsystemstask}) 
    \item[\texttt propag\_system] Propagates planet time-dependant parameters (position, velocity, distance, separation, exozodiacal brightness, delta magnitude, and working angle) in time (see \S\ref{sec:propagsystemtask})
    \item[\texttt set\_planet\_phase]
    \item[\texttt dump\_systems] Create a dictionary of planetary properties for archiving use (see \S\ref{sec:dumpsystemstask}) 
    \item[\texttt dump\_system\_params] Create a dictionary of time-dependant planet properties for a specific target (see \S\ref{sec:dumpsystemparamstask})
    \item[\texttt load\_systems] Loads a dictionary of planetary properties into the SU object
    \item[\texttt revise\_planets\_list] Replaces Simulated Universe planet attributes with filtered values, and updates the number of planets (see \S\ref{sec:reviseplanetslisttask})
    \item[\texttt revise\_stars\_list] Revises the TargetList with filtered values, and updates the planets list accordingly (see \S\ref{sec:revisestarslisttask})
\end{itemize}

% \begin{figure}[ht]
%     \begin{center}
%         \begin{tabular}{c}
%              \includegraphics[width=\textwidth]{SimulatedUniverseTasks2}
%         \end{tabular}
%     \end{center}
%     \caption{\label{fig:simulateduniversemodule} Depiction of Simulated Universe module methods including input and updated attributes (see \ref{sec:genphysicalpropertiestask}, \ref{sec:initsystemstask}, \ref{sec:propagsystemtask}, \ref{sec:dumpsystemstask}, \ref{sec:dumpsystemparamstask}, \ref{sec:reviseplanetslisttask}, and \ref{sec:revisestarslisttask}).}
% \end{figure}

\subsubsection{Attributes}
\begin{itemize}
\item
\begin{description}
    \item[StarCatalog (StarCatalog module)]\hfill \\ StarCatalog class object (only retained if keepStarCatalog is True, see \ref{sec:starcatalog})
    \item[PlanetPopulation (PlanetPopulation module)] \hfill \\ PlanetPopulation class object (see \ref{sec:planetpopulation})
    \item[PlanetPhysicalModel (PlanetPhysicalModel module)] \hfill \\ PlanetPhysicalModel class object (see \ref{sec:planetphysicalmodel})
    \item[OpticalSystem (OpticalSystem module)] \hfill \\ OpticalSystem class object (see \ref{sec:opticalsystem})
    \item[ZodiacalLight (ZodiacalLight module)] \hfill \\ ZodiacalLight class object (see \ref{sec:zodiacallight})
    \item[BackgroundSources (BackgroundSources module)] \hfill \\ BackgroundSources class object (see \ref{sec:backgroundsources})
    \item[PostProcessing (PostProcessing module)] \hfill \\ PostProcessing class object (see \ref{sec:postprocessing})
    \item[Completeness (Completeness module)] \hfill \\ Completeness class object (see \ref{sec:completeness})
    \item[TargetList (TargetList module)] \hfill \\ TargetList class object (see \ref{sec:targetlist})
    \item[nPlans (integer)] \hfill \\ Total number of planets
    \item[plan2star (integer ndarray)] \hfill \\ Indices mapping planets to target stars in TargetList
    \item[sInds (integer ndarray)] \hfill \\ Unique indices of stars with planets in TargetList
    \item[a (astropy Quantity array)] \hfill \\ Planet semi-major axis in units of $ AU $
    \item[e (float ndarray)] \hfill \\ Planet eccentricity
    \item[I (astropy Quantity array)] \hfill \\ Planet inclination in units of $ deg $
    \item[O (astropy Quantity array)] \hfill \\ Planet right ascension of the ascending node in units of $ deg $
    \item[w (astropy Quantity array)] \hfill \\ Planet argument of periastron in units of $ deg $
    \item[Min (float)] \hfill \\ Constant initial mean anomaly for all planets (optional)
    \item[M0 (astropy Quantity array)] \hfill \\ Initial mean anomaly in units of $ deg $
    \item[p (float ndarray)] \hfill \\ Planet albedo
    \item[Rp (astropy Quantity array)] \hfill \\ Planet radius in units of $earthRad$
    \item[Mp (astropy Quantity array)] \hfill \\ Planet mass in units of $earthMass$
    \item[r (astropy Quantity n$\times$3 array)] \hfill \\ Planet position vector in units of $ AU $
    \item[v (astropy Quantity n$\times$3 array)] \hfill \\ Planet velocity vector in units of $ AU/day $
    \item[d (astropy Quantity array)] \hfill \\ Planet-star distances in units of $ AU $
    \item[s (astropy Quantity array)] \hfill \\ Planet-star apparent separations in units of $ AU $
    \item[phi (float ndarray)] \hfill \\ Planet phase function, given its phase angle
    \item[fEZ (astropy Quantity array)] \hfill \\ Surface brightness of exozodiacal light in units of $ 1/arcsec2 $, determined from \verb+ZodiacalLight.fEZ+ \S\ref{sec:fEZtask}
    \item[dMag (float ndarray)] \hfill \\ Differences in magnitude between planets and their host star
    \item[WA (astropy Quantity array)] \hfill \\ Working angles of the planets of interest in units of $arcsec$
    \item[Min (TODO)] \hfill \\ TODO
    \item[cachedir (string)] \hfill \\ Path to cache directory
    \item[commonSystemInclinations (None or list)] \hfill \\ If None, planet inclinations are independently drawn (same as always) If 2 item list or form [mean, standard deviation], stars have randomly drawn inclinations using Irange (see Planet Population) and deviations from this are drawn from a normal distribution with the mean commonSystemInclinations[0] and standard deviation commonSystemInclinations[0]
\end{description}
\end{itemize}

\subsubsection{gen\_physical\_properties Method} \label{sec:genphysicalpropertiestask}
The \verb+gen_physical_properties+ method generates the planetary systems for the current simulated universe. This routine populates arrays of the orbital elements and physical characteristics of all planets, and generates indexes that map from planet to parent star. This method does not take any explicit inputs.  It uses the inherited TargetList and PlanetPopulation modules.
\subsubsection*{Generated Module Attributes}
\begin{itemize}
\item 
\begin{description}
    \item[nPlans (integer)] \hfill \\ Total number of planets
    \item[plan2star (integer ndarray)] \hfill \\ Indices mapping planets to target stars in TargetList
    \item[sInds (integer ndarray)] \hfill \\ Unique indices of stars with planets in TargetList
    \item[a (astropy Quantity array)] \hfill \\ Planet semi-major axis in units of $ AU $
    \item[e (float ndarray)] \hfill \\ Planet eccentricity
    \item[I (astropy Quantity array)] \hfill \\ Planet inclination in units of $ deg $
    \item[O (astropy Quantity array)] \hfill \\ Planet right ascension of the ascending node in units of $ deg $
    \item[w (astropy Quantity array)] \hfill \\ Planet argument of periastron in units of $ deg $
    \item[M0 (astropy Quantity array)] \hfill \\ Initial mean anomaly in units of $ deg $
    \item[p (float ndarray)] \hfill \\ Planet albedo
    \item[Mp (astropy Quantity array)] \hfill \\ Planet mass in units of $earthMass$
    \item[Rp (astropy Quantity array)] \hfill \\ Planet radius in units of $earthRad$
\end{description}
\end{itemize}

\subsubsection{gen\_M0 Method} \label{sec:genM0task}
The \verb+gen_M0+ method generates the constant or random initial mean anomaly for each simulated planet inside of \verb+gen_physical_properties+. This method does not take any explicit inputs.
\subsubsection*{Output}
\begin{itemize}
    \item 
    \begin{description}
        \item[M0 (astropy Quantity array)] \hfill \\
        Initial mean anomalies in units of $deg$
    \end{description}
\end{itemize}

\subsubsection{init\_systems Method} \label{sec:initsystemstask}
The \verb+init_systems+ method finds initial time-dependant parameters. It assigns each planet an initial position, velocity, planet-star distance, apparent separation, phase function, delta magnitude, working angle, surface brightness of exo-zodiacal light, and initializes the planet current times to zero. This method does not take any explicit inputs.  It uses the following attributes assigned before calling this method:
\begin{itemize}
    \item \verb+SimulatedUniverse.a+
    \item \verb+SimulatedUniverse.e+
    \item \verb+SimulatedUniverse.I+
    \item \verb+SimulatedUniverse.O+
    \item \verb+SimulatedUniverse.w+
    \item \verb+SimulatedUniverse.M0+
    \item \verb+SimulatedUniverse.p+
    \item \verb+SimulatedUniverse.Mp+
    \item \verb+SimulatedUniverse.Rp+
    \item \verb+TargetList.MV+
    \item \verb+TargetList.dist+
\end{itemize}
\subsubsection*{Generated Module Attributes}
\begin{itemize}
\item 
\begin{description}
    \item[r (astropy Quantity n$\times$3 array)] \hfill \\ Planet position vector in units of $ AU $
    \item[v (astropy Quantity n$\times$3 array)] \hfill \\ Planet velocity vector in units of $ AU/day $
    \item[d (astropy Quantity array)] \hfill \\ Planet-star distances in units of $ AU $
    \item[s (astropy Quantity array)] \hfill \\ Planet-star apparent separations in units of $ AU $
    \item[phi (float ndarray)] \hfill \\ Planet phase function given its phase angle, determined from \verb+PlanetPhysicalModel.calc_Phi+ \S\ref{sec:planetphysicalmodel}
    \item[fEZ (astropy Quantity array)] \hfill \\ Surface brightness of exozodiacal light in units of $ 1/arcsec2 $, determined from \verb+ZodiacalLight.fEZ+ \S\ref{sec:fEZtask}
    \item[dMag (float ndarray)] \hfill \\ Differences in magnitude between planets and their host star
    \item[WA (astropy Quantity array)] \hfill \\ Working angles of the planets of interest in units of $arcsec$
\end{description}
\end{itemize}

\subsubsection{propag\_system Method} \label{sec:propagsystemtask}
The \verb+propag_system+ method propagates planet time-dependant parameters: position, velocity, planet-star distance, apparent separation, and surface brightness of exo-zodiacal light.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[sInd (integer)] \hfill \\ Index of the target system of interest
    \item[dt (astropy Quantity)] \hfill \\ Time increment in units of $day$, for planet position propagation
\end{description}
\end{itemize}
\subsubsection*{Updated Module Attributes}
\begin{itemize}
\item 
\begin{description}
    \item[r (astropy Quantity n$\times$3 array)] \hfill \\ Planet position vector in units of $ AU $
    \item[v (astropy Quantity n$\times$3 array)] \hfill \\ Planet velocity vector in units of $ AU/day $
    \item[d (astropy Quantity array)] \hfill \\ Planet-star distances in units of $ AU $
    \item[s (astropy Quantity array)] \hfill \\ Planet-star apparent separations in units of $ AU $
    \item[phi (float ndarray)] \hfill \\ Planet phase function given its phase angle, determined from \verb+PlanetPhysicalModel.calc_Phi+ \S\ref{sec:planetphysicalmodel}
    \item[fEZ (astropy Quantity array)] \hfill \\ Surface brightness of exozodiacal light in units of $ 1/arcsec2 $, determined from \verb+ZodiacalLight.fEZ+ \S\ref{sec:fEZtask}
    \item[dMag (float ndarray)] \hfill \\ Differences in magnitude between planets and their host star
    \item[WA (astropy Quantity array)] \hfill \\ Working angles of the planets of interest in units of $arcsec$
\end{description}
\end{itemize}

\subsubsection{set\_planet\_phase Method} \label{sec:setplanetphasetask}
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[beta (float)] \hfill \\ star-planet-observer phase angle in radians
\end{description}
\end{itemize}
\subsubsection*{Updates Attributes}
\begin{itemize}
\item
\begin{description}
    \item[r (astropy Quantity n$\times$3 array)] \hfill \\ Planet position vector in units of $ AU $
    \item[v (astropy Quantity n$\times$3 array)] \hfill \\ Planet velocity vector in units of $ AU/day $
    \item[d (astropy Quantity array)] \hfill \\ Planet-star distances in units of $ AU $
    \item[s (astropy Quantity array)] \hfill \\ Planet-star apparent separations in units of $ AU $
    \item[phi (float ndarray)] \hfill \\ Planet phase function, given its phase angle
    \item[fEZ (astropy Quantity array)] \hfill \\ Surface brightness of exozodiacal light in units of $ 1/arcsec2 $, determined from \verb+ZodiacalLight.fEZ+ \S\ref{sec:fEZtask}
    \item[dMag (float ndarray)] \hfill \\ Differences in magnitude between planets and their host star
    \item[WA (astropy Quantity array)] \hfill \\ Working angles of the planets of interest in units of $arcsec$
\end{description}
\end{itemize}

\subsubsection{dump\_systems Method} \label{sec:dumpsystemstask}
The \verb+dump_systems+ method creates a dictionary of planetary properties for archiving use.
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[systems (dict)] \hfill \\ Dictionary of planetary properties
\end{description}
\end{itemize}

\subsubsection{dump\_system\_params Method} \label{sec:dumpsystemparamstask}
The \verb+dump_system_params+ method creates a dictionary of time-dependant planet properties for a specific target.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[sInd (integer)] \hfill \\ Index of the target system of interest
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[systems (dict)] \hfill \\ Dictionary of time-dependant planet properties
\end{description}
\end{itemize}

\subsubsection{revise\_planets\_list Method} \label{sec:reviseplanetslisttask}
The \verb+revise_planets_list+ method replaces Simulated Universe planet attributes with filtered values, and updates the number of planets.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[pInds (integer ndarray)] \hfill \\  Planet indices to keep
\end{description}
\end{itemize}

\subsubsection{revise\_stars\_list Method} \label{sec:revisestarslisttask}
The \verb+revise_stars_list+ method revises the TargetList with filtered values, and updates the planets list accordingly.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[sInds (integer ndarray)] \hfill \\  Star indices to keep
\end{description}
\end{itemize}


% OBSERVATORY

\subsection{Observatory}
The Observatory module contains all of the information specific to the space-based observatory not included in the Optical System module. The module has four main methods: \verb+orbit+, \verb+solarSystem_body_position+, \verb+keepout+, and \verb+distForces+, which are implemented as functions within the module.

The observatory orbit plays a key role in determining which of the target stars may be observed for planet finding at a specific time during the mission lifetime. The Observatory module's \verb+orbit+ method takes the current mission time as input and outputs the observatory's position vector. The position vector is standardized throughout the modules to be referenced to a heliocentric equatorial frame at the J2000 epoch. The observatory's position vector is used in the \verb+keepout+ method to determine which of the stars are observable at the current mission time.

The position vectors of bright objects such as the sun, the moon, and the solar system planets, are calculated by the \verb+solarSystem_body_position+ method. 

The \verb+keepout+ method determines which target stars are observable at a specific time during the mission simulation and which are unobservable due to bright objects within the field of view. The keepout volume is determined by the specific design of the observatory and, in certain cases, by the starlight suppression system.  The \verb+keepout+ method takes the Target List module and current mission time as inputs and outputs a list of the target stars which are observable at the current time. It constructs position vectors of the target stars and bright objects which may interfere with observations with respect to the observatory. These position vectors are used to determine if bright objects are in the field of view for each of the potential stars under exoplanet finding observation.  If there are no bright objects obstructing the view of the target star, it becomes a candidate for observation in the Survey Simulation module.  The solar keepout is typically encoded as allowable angle ranges for the spacecraft-star unit vector as measured from the spacecraft-sun vector.



Finally, the \verb+distForces+ method determines the lateral and axial disturbance forces that apply on an external occulter (i.e., starshade).

In addition to these methods, the observatory definition can also encode finite resources used by the observatory throughout the mission.  The most important of these is the fuel used for stationkeeping and repointing, especially in the case of occulters which must move significant distances between observations.  Other considerations could include the use of other volatiles such as cryogens for cooled instruments, which tend to deplete solely as a function of mission time.  This module also allows for detailed investigations of the effects of orbital design on the science yield, e.g., comparing the original baseline geosynchronous 28.5\textdegree{} inclined orbit for WFIRST with an L2 halo orbit, which is the new mission baseline. 

%The input and output of the Observatory module methods are depicted in \reffig{fig:observatorymodule}.

% \begin{figure}[ht]
%     \begin{center}
%         \begin{tabular}{c}
%              \includegraphics[width=0.9\textwidth]{observatory4}
%         \end{tabular}
%     \end{center}
%     \caption{\label{fig:observatorymodule} Depiction of Observatory module methods including input and output (see \S\ref{sec:orbittask}, \S\ref{sec:ssbPosTask}, \S\ref{sec:keepouttask}, and \S\ref{sec:distforcestask}).}
% \end{figure}

\label{sec:observatory}
\subsubsection{Observatory Object Attribute Initialization}

\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[koAngleMin (float)] \hfill \\ Telescope minimum keepout angle in units of $deg$. Default value is 45.
    \item[koAngleMinMoon (float)] \hfill \\ Telescope minimum keepout angle in units of $deg$, for the Moon only. Defaults to koAngleMin.
    \item[koAngleMinEarth (float)] \hfill \\ Telescope minimum keepout angle in units of $deg$, for the Earth only. Defaults to koAngleMin.
    \item[koAngleMax (float)] \hfill \\ Telescope maximum keepout angle (for occulter) in units of $deg$. Default value is 90.
    \item[koAngleSmall (float)] \hfill \\ Telescope keepout angle for smaller (angular size) bodies in units of $deg$. Default value is 1.
    \item[ko\_dtStep (float)] \hfill \\ time step for generating koMap of stars  in units of $ day $ 
    \item[settlingTime (float)] \hfill \\ Amount of time needed for observatory to settle after a repointing in units of $ day $. Default value is 1.
    \item[thrust (float)] \hfill \\ Occulter slew thrust in units of $ mN $. Default value is 450.
    \item[slewIsp (float)] \hfill \\ Occulter slew specific impulse in units of $ s $. Default value is 4160.
    \item[scMass (float)] \hfill \\ Occulter (maneuvering spacecraft) initial wet mass in units of $ kg $. Default value is 6000.
    \item[dryMass (float)] \hfill \\ Occulter (maneuvering spacecraft) dry mass in units of $ kg $. Default value is 3400.
    \item[slewMass (float)] \hfill \\ Occulter (maneuvering spacecraft) initial fuel mass used for slewing in units of $ kg $. Default value is 0.
    \item[skMass (float)] \hfill \\ Occulter (maneuvering spacecraft) initial fuel mass used for station keeping in units of $ kg $. Default value is 0.
    \item[twotanks (boolean)] \hfill \\ Boolean signifying if the Occulter (maneuvering spacecraft) has two separate fuel tanks. If true, decrements mass from slewMass and skMass. Default value is False.
    \item[slewEff (float)] \hfill \\ Occulter slewing maneuver general efficiency factor. Default value is 1.0.
    \item[skEff (float)] \hfill \\ Occulter station keeping maneuver general efficiency factor. Default value is 0.7098.
    \item[coMass (float)] \hfill \\ Telescope (or non-maneuvering spacecraft) mass in units of $ kg $. Default value is 5800.
    \item[occulterSep (float)] \hfill \\ Occulter-telescope distance in units of $ km $. Default value is 55000.
    \item[skIsp (float)] \hfill \\ Specific impulse for station keeping in units of $ s $. Default value is 220.
    \item[defburnPortion (float)] \hfill \\ Default burn portion for slewing. Default value is 0.05
    \item[constTOF (float)] \hfill \\ Occulter constant slewtime in $ days $
    \item[maxdVpct (float)] \hfill \\ Occulter maximum dV as percentage of total (must be <= 1)
    \item[spkpath (string)] \hfill\\ String with full path to SPK kernel file (only used if using jplephem for solar system body propagation - see \ref{sec:ssbPosTask}).
    \item[checkKeepoutEnd (boolean)] \hfill \\ Boolean signifying if the keepout method must be called at the end of each observation.
    \item[forceStaticEphem (boolean)] \hfill \\ Boolean, forcing use of static solar system ephemeris if set to True, even if jplephem module is present (see \ref{sec:ssbPosTask}).  Default value is False.
    \item[occ\_dtmin (float)] \hfill \\ Maximum occulter slew time (days)
    \item[occ\_dtmax (float)] \hfill \\ Minimum occulter slew time (days)
    %\item[occ_dtStep (float)] \hfill \\ 
\end{description}
\end{itemize}

\subsubsection*{Attributes}
\begin{itemize}
\item
\begin{description}
    \item[koAngleMin (astropy Quantity)] \hfill \\ Telescope minimum keepout angle in units of $deg$
    \item[koAngleMinMoon (astropy Quantity)] \hfill \\ Telescope minimum keepout angle in units of $deg$, for the Moon only
    \item[koAngleMinEarth (astropy Quantity)] \hfill \\ Telescope minimum keepout angle in units of $deg$, for the Earth only
    \item[koAngleMax (astropy Quantity)] \hfill \\ Telescope maximum keepout angle (for occulter) in units of $deg$
    \item[koAngleSmall (astropy Quantity)] \hfill \\ Telescope keepout angle for smaller (angular size) bodies in units of $deg$
    \item[ko\_dtStep (float)] \hfill \\ time step for generating koMap of stars  in units of $ day $ 
    \item[settlingTime (astropy Quantity)] \hfill \\ Amount of time needed for observatory to settle after a repointing in units of $ day $
    \item[thrust (astropy Quantity)] \hfill \\ Occulter slew thrust in units of $ mN $
    \item[slewIsp (astropy Quantity)] \hfill \\ Occulter slew specific impulse in units of $ s $
    \item[scMass (astropy Quantity)] \hfill \\ Occulter (maneuvering spacecraft) initial wet mass in units of $ kg $
    \item[dryMass (astropy Quantity)] \hfill \\ Occulter (maneuvering spacecraft) dry mass in units of $ kg $
    \item[slewMass (astropy Quantity)] \hfill \\ Occulter (maneuvering spacecraft) fuel mass used for slewing in units of $ kg $
    \item[skMass (astropy Quantity)] \hfill \\ Occulter (maneuvering spacecraft) fuel mass used for station keeping in units of $ kg $
    \item[twotanks (boolean)] \hfill \\ Boolean signifying if the Occulter (maneuvering spacecraft) has two separate fuel tanks
    \item[slewEff (float)] \hfill \\ Occulter slewing maneuver general efficiency factor
    \item[skEff (float)] \hfill \\ Occulter station keeping maneuver general efficiency factor
    \item[coMass (astropy Quantity)] \hfill \\ Telescope (or non-maneuvering spacecraft) mass in units of $ kg $
    \item[occulterSep (astropy Quantity)] \hfill \\ Occulter-telescope distance in units of $ km $
    \item[skIsp (astropy Quantity)] \hfill \\ Specific impulse for station keeping in units of $ s $
    \item[defburnPortion (float)] \hfill \\ Default burn portion for slewing
    \item[checkKeepoutEnd (boolean)] \hfill \\ Boolean signifying if the keepout method must be called at the end of each observation
    \item[forceStaticEphem (boolean)] \hfill \\ Boolean, forcing use of static solar system ephemeris if set to True.
    \item[constTOF (float)] \hfill \\ Constant occulter slew time in $ day $
    \item[occ\_dtmin (float)] \hfill \\ Minimum occulter slew time in $ day $
    \item[occ\_dtmax (float)] \hfill \\ Maximum occulter slew time in $ day $
    \item[maxdVpct (float)] \hfill \\ Maximum slew dV as percentage of initial dV
    %\item[flowRate (astropy Quantity)] \hfill \\ Slew flow rate derived from thrust and slewIsp in units of $ kg/day $
    \item[dVtot (float)] \hfill \\ Total amount of dV onboard the spacecraft
    \item[dVmax (float)] \hfill \\ Maximum dV per occulter slew
    \item[flowRate (float)] \hfill \\ Slew flow rate in $kg/day$
    \item[havejplephem (boolean)] \hfill \\ Boolean indicating static solar ephemerides are being used when False
    \item[obe (lambda function)] \hfill \\ A lambda function for calculating the obliquity of the ecliptic
    \item[kernel (jplephem object)] \hfill \\ The spk ephemeris, exists only if havejplephem is True
    \item[planets (list of dict)] \hfill \\ A dictionary containing the planets names
    \item[cachedir (string)] \hfill \\ Path to cache directory
\end{description}
\end{itemize}

\subsubsection{equat2eclip Method} \label{sec:equat2eclip}
Rotates heliocentric coordinates from equatorial frame to ecliptic frame
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[r\_equat (astropy Quantity nx3 array)] \hfill \\ Positions vector in heliocentric equatorial frame in units of AU
    \item[currentTime (astropy Time array)] \hfill \\ Current absolute mission time in MJD
    \item[rotsign (integer)] \hfill \\ Optional flag, default 1, set -1 to reverse the rotation
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[r\_eclip (qstropy Quantity nx3 array)] \hfill \\ Positions vector in heliocentric ecliptic frame in units of AU
\end{description}
\end{itemize}

\subsubsection{eclip2equat Method} \label{sec:eclip2equat}
Rotates heliocentric coordinates from ecliptic to equatorial frame.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[r\_eclip (astropy Quantity nx3 array)] \hfill \\ Positions vector in heliocentric ecliptic frame in units of AU
    \item[currentTime (astropy Time array)] \hfill \\ Current absolute mission time in MJD
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[r\_equat (astropy Quantity nx3 array)] \hfill \\ Positions vector in heliocentric equatorial frame in units of AU
\end{description}
\end{itemize}

\subsubsection{orbit Method} \label{sec:orbittask}
The \verb+orbit+ method finds the heliocentric equatorial position vector of the observatory spacecraft.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[currentTime (astropy \href{http://astropy.readthedocs.org/en/latest/time/index.html}{Time} array)] \hfill \\ Current absolute mission time in MJD
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[r\_sc (astropy Quantity n$\times$3 array)] \hfill \\ Observatory orbit position in HE reference frame at current mission time in units of $ km $
\end{description}
\end{itemize}

\subsubsection{keepout Method} \label{sec:keepouttask} 
The \verb+keepout+ method determines which stars in the target list are observable at the given input time.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[TL (TargetList module)] \hfill \\ TargetList class object, see \S\ref{sec:targetlist} for definition of available attributes
    \item[sInds (integer ndarray)] \hfill \\ Integer indices of the stars of interest
    \item[currentTime (astropy \href{http://astropy.readthedocs.org/en/latest/time/index.html}{Time} array)] \hfill \\ Current absolute mission time in MJD
    \item[mode (dict)] \hfill \\ Selected observing mode (from OpticalSystem)
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[kogood (boolean ndarray)] \hfill \\ True is a target unobstructed and observable, and False is a target unobservable due to obstructions in the keepout zone.
\end{description}
\end{itemize}

\subsubsection{generate\_koMap Method} \label{sec:generatekoMaptask}
This function creates a keepout map for all targets from missionStart until the end of mission.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[TL (module)] \hfill \\ The Target List module
    \item[missionStart (astropy Time)] \hfill \\ The absolute start time of mission in MJD
    \item[missionFinishAbs] \hfill \\ The absolute end time of mission in MJD
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[koMap (boolean ndarray)] \hfill \\ A binary array with TargetList.nStars rows and (missionFinishAbs-missionStart)/dt columns where dt is 1 day by default. A value of 1 indicates the star is in keepout for (and therefore cannot be observed). A value of 0 indicates the star is not in keepout and may be observed.
    \item[koTimes (astropy Time ndarray)] \hfill \\ An array of astropy Times corresponding to each column in koMap. Ex koMap[0,7] maps to koTimes[7] 
\end{description}
\end{itemize}

\subsubsection{calculate\_observableTimes Method}
For Occulters and No Occulter systems. Calculates the next window of observable times for a given set of stars specified by sInds such that the returned observableTimes has dimensions len(sInds)x2. If sInds has one star such that sInds=[0], then the returned array observableTimes is 1x2 where observableTimes[0,0] is the start time the next star will be observable and observableTimes[0,1] is the end time the next star will be observable.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[TL (module)] \hfill \\ The Target List module
    \item[sInds (numpy array)] \hfill \\ The indices of the stars to calculate observable Times for
    \item[currentTime (astropy Time)] \hfill \\ The current absolute mission time in MJD
    \item[koMap] \hfill \\ The keepout map generated by generate\_koMap method
    \item[koTimes] \hfill \\ The keepout map Times associated with the keepout map
    \item[mode (list dict)] \hfill \\ the operating mode of the instrument used for determining whether occulter needs to be accounted for.
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[observableTimes (astropy Time list)] \hfill \\ A binary array with TargetList.nStars rows and (missionFinishAbs-missionStart)/dt columns where dt is 1 day by default. A value of 1 indicates the star is in keepout for (and therefore cannot be observed). A value of 0 indicates the star is not in keepout and may be observed.
    \item[koTimes (astropy Time ndarray)] \hfill \\ An array of astropy Times corresponding to each column in koMap. Ex koMap[0,7] maps to koTimes[7] 
\end{description}
\end{itemize}

\subsubsection{find\_nextObsWindow Method}
This function should only be called by calculate\_observableTimes. *For No Occulter systems.Calculates the next window of observable times for a given set of stars specified by sInds such that the returned observableTimes has dimensions len(sInds)x2. If sInds has one star such that sInds=[0], then the returned array observableTimes is 1x2 where observableTimes[0,0] is the start time the next star will be observable and observableTimes[0,1] is the end time the next star will be observable.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[TL (module)] \hfill \\ The Target List module
    \item[sInds (numpy array)] \hfill \\ The indices of the stars to calculate observable Times for
    \item[currentTime (astropy Time)] \hfill \\ The current absolute mission time in MJD
    \item[koMap] \hfill \\ The keepout map generated by generate\_koMap method
    \item[koTimes] \hfill \\ The keepout map Times associated with the keepout map
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[observableTimes (astropy Time list)] \hfill \\ A binary array with TargetList.nStars rows and (missionFinishAbs-missionStart)/dt columns where dt is 1 day by default. A value of 1 indicates the star is in keepout for (and therefore cannot be observed). A value of 0 indicates the star is not in keepout and may be observed.
    \item[koTimes (astropy Time ndarray)] \hfill \\ An array of astropy Times corresponding to each column in koMap. Ex koMap[0,7] maps to koTimes[7] 
\end{description}
\end{itemize}

\subsubsection{star\_angularSep Method} \label{sec:starangsep}
Finds angular separation from old star to given list of stars.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[TL (TargetList module)] \hfill \\ TargetList class object
    \item[old\_sInd (integer)] \hfill \\ Integer index of the last star of interest
    \item[sInds (integer ndarray)] \hfill \\ Integer indices of the stars of interest
    \item[currentTime (astropy Time array)] \hfill \\ Current absolute mission time in $ MJD $
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[sd (integer)] \hfill \\ Angular separation mission time in $ MJD $
\end{description}
\end{itemize}

\subsubsection{solarSystem\_body\_position Method} \label{sec:ssbPosTask}
The \verb+solarSystem_body_position+ returns the position of any solar system body (Earth, Sun, Moon, etc.) at a given time in the common Heliocentric Equatorial frame.  The observatory prototype will attempt to load the jplephem module, and use a local SPK file for all propagations if available.  The SPK file is not packaged with the software but may be downloaded from JPL's website at: \url{http://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/}.  The location of the spk file is assumed to be in the Observatory directory but can be set by the \verb+spkpath+ input.  

If jplephem is not present, the Observatory prototype will load static ephemeris derived from Vallado (2004) and use those for propagation.  This behavior can be forced even when jplephem is available by setting the \verb+forceStaticEphem+ input to True.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[currentTime (astropy \href{http://astropy.readthedocs.org/en/latest/time/index.html}{Time})] \hfill \\ Current absolute mission time in MJD
    \item[bodyname (string)] \hfill \\ Solar system object name, capitalized by convention
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[r\_body (astropy Quantity n$\times$3 array)] \hfill \\ Heliocentric equatorial position vector in units of $ km $
\end{description}
\end{itemize}

\subsubsection{spk\_body Method} \label{sec:spkbody}
Finds solar system body positions vector in heliocentric equatorial (default) or ecliptic frame for current time (MJD).
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[currentTime (astropy Time array)] \hfill \\ Current absolute mission time in $MJD$
    \item[bodyname (string)] \hfill \\ Solar system object name
    \item[eclip (boolean)] \hfill \\Boolean used to switch to heliocentric ecliptic frame. Defaults to False, corresponding to heliocentric equatorial frame.
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[r\_body (astropy Quantity nx3 array)] \hfill \\ Solar system body positions in heliocentric equatorial (default) or ecliptic frame in units of $AU$
\end{description}
\end{itemize}

\subsubsection{keplerplanet Method} \label{sec:keplerplanet}
Finds solar system body positions vector in heliocentric equatorial (default) or ecliptic frame for current time (MJD).
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[currentTime (astropy Time array)] \hfill \\ Current absolute mission time in $MJD$
    \item[bodyname (string)] \hfill \\ Solar system object name
    \item[eclip (boolean)] \hfill \\ Boolean used to switch to heliocentric ecliptic frame. Defaults to False, corresponding to heliocentric equatorial frame.
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[r\_body (astropy Quantity nx3 array)] \hfill \\ Solar system body positions in heliocentric equatorial (default) or ecliptic frame in units of AU
\end{description}
\end{itemize}

\subsubsection{moon\_earth Method} 
Finds geocentric equatorial positions vector for Earth's moon using Algorithm 31 from Vallado 2013 to find the geocentric equatorial positions vector for Earth's moon.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[currentTime (astropy Time array)] \hfill \\ Current absolute mission time in $MJD$
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[r\_moon (astropy Quantity nx3 array)] \hfill \\ Geocentric equatorial position vector in units of AU
\end{description}
\end{itemize}

\subsubsection{cent Method} 
Finds time in Julian centuries since J2000 epoch. This quantity is needed for many algorithms from Vallado 2013.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[currentTime (astropy Time array)] \hfill \\ Current absolute mission time in $MJD$
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[TBD (float ndarray)] \hfill \\ time in Julian centuries since the J2000 epoch 
\end{description}
\end{itemize}

\subsubsection{propeph Method} 
Propagates an ephemeris from Vallado 2013 to current time.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[x (list)] \hfill \\ ephemeride list (maximum of 4 elements)
    \item[TBD (float)] \hfill \\ time in Julian centuries since the J2000 epoch 
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[y (float ndarray)] \hfill \\ ephemeride value at current time
\end{description}
\end{itemize}

\subsubsection{rot Method} 
Finds the rotation matrix of angle th about the axis value
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[th (float)] \hfill \\ Rotation angle in radians
    \item[axis (int)] \hfill \\ Integer value denoting rotation axis (1,2, or 3)
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[rot\_th (float 3x3 ndarray)] \hfill \\ Rotation matrix
\end{description}
\end{itemize}

\subsubsection{distForces Method} \label{sec:distforcestask} 
The \verb+distForces+ method finds lateral and axial disturbance forces on an occulter.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[TL (TargetList module)] \hfill \\ TargetList class object, see \S\ref{sec:targetlist} for definition of available attributes
    \item[sInd (integer)] \hfill \\ Integer index of the star of interest
    \item[currentTime (astropy \href{http://astropy.readthedocs.org/en/latest/time/index.html}{Time} array)] \hfill \\ Current absolute mission time in MJD
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[dF\_lateral (astropy Quantity)] \hfill \\ Lateral disturbance force in units of $N$
    \item[dF\_axial (astropy Quantity)] \hfill \\ Axial disturbance force in units of $N$
\end{description}
\end{itemize}

\subsubsection{mass\_dec Method} 
Returns mass used and deltaV, the values returned by this method are used to decrement spacecraft mass for station-keeping.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[dF\_lateral (astropy Quantity)] \hfill \\ Lateral disturbance force in units of $N$
    \item[t\_int (astropy Quantity)] \hfill \\ Integration time in units of $day$
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[intMdot (astropy Quantity)] \hfill \\ Mass flow rate in units of kg/s
    \item[mass\_used (astropy Quantity)] \hfill \\ Mass used in station-keeping units of kg
    \item[deltaV (astropy Quantity)] \hfill \\ Change in velocity required for station-keeping in units of km/s
\end{description}
\end{itemize}

\subsubsection{mass\_dec\_sk Method} 
Returns mass used, deltaV and disturbance forces. This method calculates all values needed to decrement spacecraft mass for station-keeping.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[TL (TargetList module)] \hfill \\ TargetList class object
    \item[sInd (integer)] \hfill \\ Integer index of the star of interest
    \item[currentTime (astropy Time array)] \hfill \\ Current absolute mission time in $MJD$
    \item[t\_int (astropy Quantity)] \hfill \\ Integration time in units of $day$
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[dF\_lateral (astropy Quantity)] \hfill \\ Lateral disturbance force in units of $N$
    \item[dF\_axial (astropy Quantity)] \hfill \\ Axial disturbance force in units of $N$
    \item[intMdot (astropy Quantity)] \hfill \\ Mass flow rate in units of kg/s
    \item[mass\_used (astropy Quantity)] \hfill \\ Mass used in station-keeping units of kg
    \item[deltaV (astropy Quantity)] \hfill \\ Change in velocity required for station-keeping in units of km/s
\end{description}
\end{itemize}

\subsubsection{calculate\_dV Method} 
Finds the change in velocity needed to transfer to a new star line of sight. This method sums the total delta-V needed to transfer from one star line of sight to another. It determines the change in velocity to move from one station-keeping orbit to a transfer orbit at the current time, then from the transfer orbit to the next station-keeping orbit at currentTime + dt. Station-keeping orbits are modeled as discrete boundary value problems. This method can handle multiple indeces for the next target stars and calculates the dVs of each trajectory from the same starting star.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[dt (float 1x1 ndarray)] \hfill \\ Number of days corresponding to starshade slew time
    \item[TL (float 1x3 ndarray)] \hfill \\ TargetList class object
    \item[nA (integer)] \hfill \\ Integer index of the current star of interest
    \item[N (integer)] \hfill \\ Integer index of the next star(s) of interest
    \item[tA (astropy Time array)] \hfill \\ Current absolute mission time in $MJD$
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[dV (float nx6 ndarray)] \hfill \\ State vectors in rotating frame in normalized units
\end{description}
\end{itemize}

\subsubsection{calculate\_slewTimes Method} 
Finds slew times and separation angles between target stars. This method determines the slew times of an occulter spacecraft needed to transfer from one star's line of sight to all others in a given target list.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[TL (TargetList module)] \hfill \\ TargetList class object
    \item[old\_sInd (integer)] \hfill \\ Integer index of the most recently observed star
    \item[sInds (integer ndarray)] \hfill \\ Integer indeces of the star of interest
    \item[sd (astropy Quantity)] \hfill \\ Angular separation between stars in rad
    \item[observableTimes (astropy Time list)] \hfill \\ A binary array with TargetList.nStars rows and (missionFinishAbs-missionStart)/dt columns where dt is 1 day by default. A value of 1 indicates the star is in keepout for (and therefore cannot be observed). A value of 0 indicates the star is not in keepout and may be observed.
    \item[currentTime (astropy Time array)] \hfill \\ Current absolute mission time in $MJD$
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[slewTimes (astropy Quantity)] \hfill \\ Time to transfer to new star line of sight in units of $days$
\end{description}
\end{itemize}

\subsubsection{log\_occulterResults Method} 
Updates the given DRM to include occulter values and results
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[DRM (dict)] \hfill \\ Design Reference Mission, contains the results of one complete observation (detection and characterization)
    \item[slewTimes (astropy Quantity)] \hfill \\ Time to transfer to new star line of sight in units of days
    \item[sInd (integer)] \hfill \\ Integer index of the star of interest
    \item[sd (astropy Quantity)] \hfill \\ Angular separation between stars in rad
    \item[dV (astropy Quantity)] \hfill \\ Delta-V used to transfer to new star line of sight in units of m/s
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[DRM (dict)] \hfill \\ Design Reference Mission, contains the results of one complete observation (detection and characterization)
\end{description}
\end{itemize}


% TIME KEEPING 

\subsection{Time Keeping} \label{sec:timekeeping}
The Time Keeping module is responsible for keeping track of the current mission time, exoplanet observation time, and observing blocks.  It encodes the mission start time, mission life, mission portion, mission end time, current time within a simulation, start times of observing blocks, end times of observing blocks, observation block number, and observation time counted towards an instrument.  All functions in all modules requiring knowledge of the current time call functions or access parameters implemented within the Time module.  Internal encoding of time is implemented as the time from mission start (measured in units of $ day $).  The Time Keeping module also provides functionality for converting between this time measure and standard measures such as Julian Day Number and UTC time.
 
%The input, output and updated attributes of the Time Keeping methods are depicted in \reffig{fig:timekeepingmodule}. 
The Time Keeping module contains six methods:
\begin{itemize}[leftmargin=1.5in,font={\ttfamily}]
    \item[\texttt init\_OB] Initializes the mission observing blocks (see \S\ref{sec:initobtask})
    \item[\texttt mission\_is\_over] Evaluates whether the mission is over given the current timekeeping values (see \S\ref{sec:missionisovertask})
    \item[\texttt allocate\_time] Allocates a temporal block of width $dt$, updating the mission time during a survey simulation (see \S\ref{sec:allocatetimetask})
    \item[\texttt advanceToAbsTime] Advances mission time to absolute time specified accounting for observation blocks (see \S\ref{sec:advancetoabstimetask})
    \item[\texttt advancetToStartOfNextOB] Advances mission time to the start of the next Observing Block (see \S\ref{sec:advancetToStartOfNextOBtask})
    %\item[\texttt get\_tEndThisOB] Returns the end time of the current observing block (see \S\ref{sec:get_tEndThisOBtask})
    \item[\texttt get\_ObsDetectionMaxIntTime] Returns the maximum integration times that can be passed into the prototype observation\_detection (see \S\ref{sec:observationdetectiontask}) as limited by observing blocks, exoplanet observation time, and mission life (see \S\ref{sec:get_ObsDetectionMaxIntTime})
\end{itemize}

% \begin{figure}[ht]
%     \begin{center}
%         \begin{tabular}{c}
%              \includegraphics[width=\textwidth]{TimeKeepingTasks3}
%         \end{tabular}
%     \end{center}
%     \caption{\label{fig:timekeepingmodule} Depiction of Time Keeping module method including input, output, and updated attributes (see \S\ref{sec:allocatetimetask}, \S\ref{sec:advancetToStartOfNextOBtask}, and \S\ref{sec:missionisovertask}).}
% \end{figure}

\subsubsection{Time Keeping Object Attribute Initialization}
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[missionStart (float)] \hfill \\ Mission start time in $ MJD $. Default value is 60634.
    \item[missionLife (float)] \hfill \\ Total length of mission in units of $ year $. Default value is 0.1.
    \item[missionPortion (float)] \hfill \\ Portion of mission time devoted to planet-finding. Default value is 1.
    \item[OBduration (float)] \hfill \\ Default allocated duration of observing blocks in units of $day$. Default value is np.inf.
    \item[missionSchedule (string)] \hfill \\ Name of CSV file containing Observation Blocks start and end times.
\end{description}
\end{itemize}
\subsubsection*{Attributes}
\begin{itemize}
\item
\begin{description}
    \item[missionStart (astropy \href{http://astropy.readthedocs.org/en/latest/time/index.html}{Time})] \hfill \\
        Mission start time in $ MJD $
    \item[missionLife (astropy Quantity)] \hfill \\ Mission lifetime in units of $ year $
    \item[missionPortion (float)] \hfill \\ Portion of mission time devoted to planet-finding
    \item[missionFinishAbs (astropy \href{http://astropy.readthedocs.org/en/latest/time/index.html}{Time})] \hfill \\ Mission completion date in $ MJD $
    \item[currentTimeNorm (astropy Quantity)] \hfill \\ Current mission time normalized so that start date is 0, in units of $ day $
    \item[currentTimeAbs (astropy \href{http://astropy.readthedocs.org/en/latest/time/index.html}{Time})] \hfill \\ Current absolute mission time in $ MJD $
    \item[OBnumber (integer)] \hfill \\ Index/number associated with the current observing block (OB). Each observing block has a duration, a start time, an end time, and can host one or multiple observations.
    \item[OBduration (astropy Quantity)] \hfill \\ Default allocated duration of observing blocks, in units of $day$. If no OBduration was specified, a new observing block is created for each new observation in the SurveySimulation module. 
    \item[OBstartTimes (astropy Quantity array)] \hfill \\ Array containing the normalized start times of each observing block throughout the mission, in units of $day$
    \item[OBendTimes (astropy Quantity array)] \hfill \\ Array containing the normalized end times of each observing block throughout the mission, in units of $day$
    \item[exoplanetObsTime (astropy Quantity)] \hfill \\ Tracks instrument time used in units of $day$
    \item[cachedir (string)] \hfill \\ Path to cache directory
\end{description}
\end{itemize}

\subsubsection{init\_OB Method} \label{sec:initobtask}
The init\_OB method is ONLY called to instantiate the observing blocks at the beginning of the mission. The function takes in the name of the CSV format file containing the missionSchedule (stored in the Scripts folder) and the OBduration. Both missionSchedule and OBduration are designed to be defined in the JSON script. This method initializes mission observing blocks in priority order:
\begin{enumerate}
    \item A CSV file specified in the missionSchedule field of the JSON script. The observing blocks are exactly specified by the start and end times in the CSV file.
    \item The OBduration, missionPortion, and missionLife specifications in the  script (automatically creating observing blocks of length OBduration and constant period repetition)
    \item Defaults to single observing block with duration missionLife $\times$ missionPortion
\end{enumerate}
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[missionSchedule (string)] \hfill \\ Filename of a CSV file containing the mission observation block start and end times which are presented in units of day (defaults to None)
    \item[OBduration (astropy Quantity)] \hfill \\ the duration of a single observation block, used if a mission schedule is not provided. (units of $day$)
\end{description}
\end{itemize}
\subsubsection*{Updated Module Attributes}
\begin{itemize}
\item 
\begin{description}
    \item[OBstartTimes (astropy Quantity array)] \hfill \\ contains the start times of every observation block specified as times since mission start
    \item[OBendTimes (astropy Quantity array)] \hfill \\ contains the end times of every observation block specified as times since mission start
    \item[OBnumber (integer)] \hfill \\ the index indicating the current observation block the mission is in ex. OBstartTimes[OBnumber]
\end{description}
\end{itemize}

\subsubsection{allocate\_time Method} \label{sec:allocatetimetask}
Allocate a continguous temporal block of width dt. If time advancement would place the mission time outside of an observing block, past the end of mission, or exceed exoplanet observation time, then a false flag will be returned and time will not advanced by dt. allocate\_time is designed to be called by observation characterization and observation detection methods. Observation characterization will skip characterization if time allocation fails. Observation detection produces a global error if time allocation fails. The maximum integration time returnable by next\_target can be retrieved by calling get\_ObsDetectionMaxIntTime.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[dt (astropy Quantity)] \hfill \\ Temporal block allocated in units of $ day $
    \item[addExoplanetObsTime (bool)] \hfill \\ A True flag indicates dt to allocate is to be counted towards exoplanet observation time otherwise no time is added to exoplanet observation time (default is True)
\end{description}
\end{itemize}
\subsubsection*{Updated Module Attributes}
\begin{itemize}
\item 
\begin{description}
    \item[currentTimeNorm (astropy Quantity)] \hfill \\ Current mission time normalized so start date is 0, in units of $ day $ is advanced by dt
    \item[currentTimeAbs (astropy \href{http://astropy.readthedocs.org/en/latest/time/index.html}{Time})] \hfill \\ Current absolute mission time in $ MJD $ in advanced by dt
    \item[exoplanetObsTime (astropy Quantity)] \hfill \\ exoplanet Obs time is advanced by dt if time allocation does not fail and addExoplanetObsTime flag is True
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[success (boolean)] \hfill \\ True if dt could be allocated. False if allocated time exceeds the end of mission time, the end of the observing block, exceeds the total allowed mission time.
\end{description}
\end{itemize}

\subsubsection{advanceToAbsTime Method} \label{sec:advancetoabstimetask}
Advances mission time to the specified absolute time. If the absolute time to advance to is outside of an observing block, time will advance to the start of the next observing block. The absolute time to be advanced to can be past the mission finish time. The addExoplanetObsTime flag indicates whether time within observing blocks between now and the time to advance to will count towards exoplanet observation time.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[tAbs (astropy Time)] \hfill \\ Absolute Time to be advanced to in $ MJD $
    \item[addExoplanetObsTime (bool)] \hfill \\ A True flag indicates t to allocate is to be counted towards exoplanet observation time otherwise no time is added to exoplanet observation time (default is True)
\end{description}
\end{itemize}
\subsubsection*{Updated Module Attributes}
\begin{itemize}
\item 
\begin{description}
    \item[currentTimeNorm (astropy Quantity)] \hfill \\ Current mission time normalized so that start date is 0, in units of $ day $
    \item[currentTimeAbs (astropy \href{http://astropy.readthedocs.org/en/latest/time/index.html}{Time})] \hfill \\ Current absolute mission time in $ MJD $
    \item[exoplanetObsTime (astropy Quantity)] \hfill \\ exoplanet Obs time is advanced by dt if time allocation does not fail and addExoplanetObsTime flag is True
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[success (bool)] \hfill \\ False if advancing tAbs would exceed exoplantObsTime. True under all other conditions
\end{description}
\end{itemize}

\subsubsection{advancetToStartOfNextOB Method} \label{sec:advancetToStartOfNextOBtask}
Advances to Start of Next Observation Block. This method is called from run\_sim following an allocate\_time or advanceToAbsTime function call. Since allocate\_time is designed to allocate time up and to OBendTimes[OBnumber], advancetToAbsTime is a mechanism for advancing time to the start of the next OB.
\subsubsection*{Updated Module Attributes}
\begin{itemize}
\item 
\begin{description}
    \item[OBnumber (integer)] \hfill \\ Index/number associated with the current observing block (OB). Each observing block has a duration, a start time, an end time, and can host one or multiple observations.
    \item[currentTimeNorm (astropy Quantity)] \hfill \\ Current mission time normalized so that start date is 0, in units of $ day $
    \item[currentTimeAbs (astropy \href{http://astropy.readthedocs.org/en/latest/time/index.html}{Time})] \hfill \\ Current absolute mission time in $ MJD $
\end{description}
\end{itemize}

\subsubsection{mission\_is\_over Method} \label{sec:missionisovertask}
The \verb+mission_is_over+ method does not take any explicit inputs.  It compares the updated module attribute \verb+currentTimeNorm+ to \verb+missionLife+ and last \verb+OBendTimes+ for termination conditions. We also compare \verb+exoplanetObsTime+ to the total mission time dedicates to observations.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[Obs (Observatory object)] \hfill \\ Observatory module for use of Obs.settlingTime
    %\item[settlingTime (astropy Quantity)] \hfill \\ Observatory settling time (Obs.settlingTime should be passed in)
    \item[mode (dict)] \hfill \\ mode dictionary for ohTime
    %\item[ohTime (astropy Quantity)] \hfill \\ Instrument overhead time (mode['syst']['ohTime'] should be passed in)
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[is\_over (boolean)] \hfill \\ True if the mission time is used up, else False
\end{description}
\end{itemize}

\subsubsection{get\_ObsDetectionMaxIntTime} \label{sec:get_ObsDetectionMaxIntTime}
Calculates the maximum integration times possible without exceeding allocate\_time scheduling constraints: 1) OBendTime, 2) exoplanetObsTime, and 3) missionLife. The calculation includes the time multiplier, system settling time, and system overhead time.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[Obs (Observatory object)] \hfill \\ Observatory module for use of Obs.settlingTime
    %\item[settlingTime (astropy Quantity)] \hfill \\ Observatory settling time (Obs.settlingTime should be passed in)
    \item[mode (dict)] \hfill \\ mode dictionary for ohTime
    %\item[ohTime (astropy Quantity)] \hfill \\ Instrument overhead time (mode['syst']['ohTime'] should be passed in)
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[maxIntTimeOBendTime (astropy Quantity)] \hfill \\ The maximum integration time that can be passed into observation detection without exceeding the observing block end time in units of $day$
    \item[maxIntTimeExoplanetObsTime (astropy Quantity)] \hfill \\ The maximum integration time that can be passed into observation detection without exceeding the exoplanet observation time in units of $day$
    \item[maxIntTimeMissionLife (astropy Quantity)] \hfill \\ The maximum integration time that can be passed into observation detection without exceeding the mission life in units of $day$
\end{description}
\end{itemize}

%\subsubsection{get\_tStartNextOB Method} \label{sec:get_tStartNextOBtask}
%This function does not take any explicit inputs. This function returns start time of next Observing Block (OB) or the End Time of the mission if there are no more schedules observing blocks.
%
%\subsubsection*{Output}
%\begin{itemize}
%\item 
%\begin{description}
%    \item[nextOBstartTime (float astropy Quantity)] \hfill \\ the next time the observatory is available for observing
%\end{description}
%\end{itemize}

%\subsubsection{get\_tEndThisOB Method} \label{sec:get_tEndThisOBtask}
%This method does not take any explicit inputs. This function returns the end time of the current Observing Block or the end of mission time.
%
%\subsubsection*{Output}
%\begin{itemize}
%\item 
%\begin{description}
%    \item[nextOBendTime (float astropy Quantity)] \hfill \\ the end time of the current observation block
%\end{description}
%\end{itemize}

% SURVEY SIMULATION

\subsection{Survey Simulation} \label{sec:surveysim}
This is the module that performs a specific simulation based on all of the input parameters and models. This module returns the mission timeline - an ordered list of simulated observations of various targets on the target list along with their outcomes.  The output also includes an encoding of the final state of the simulated universe (so that a subsequent simulation can start from where a previous simulation left off) and the final state of the observatory definition (so that post-simulation analysis can determine the percentage of volatiles expended, and other engineering metrics).

%The input, output and updated attributes of the Survey Simulation methods are depicted in \reffig{fig:surveysimulationmodule}. 
The Survey Simulation module contains the following methods:
\begin{itemize}[leftmargin=2.5in,font={\ttfamily}]
    \item[\texttt run\_sim] Performs the survey simulation (see \S\ref{sec:runsimtask})
    \item[\texttt next\_target] Finds index of next target star and calculates its integration time (see \S\ref{sec:nexttargettask}) - called by \verb+run_sim+
    %\item[\texttt intTimeFilter] Filters targets with fZ optimal integration time at dMagint greater than OS.intCutoff (see \S\ref{sec:intTimeFiltertask}) - called by \verb+next_target+
    \item[\texttt calc\_targ\_intTime] Calculate integration times for a subset of targets give the start of observation time (see \S\ref{sec:calcTargIntTimetask}) - called by \verb+intTimeFilter+
    \item[\texttt choose\_next\_target] Given a subset of targets, select the next target to observe OR specify some waitTime (see \S\ref{sec:chooseNextTargettask}) - called by \verb+next_target+
    \item[\texttt observation\_detection] Determines detection status for a given integration time  (see \S\ref{sec:observationdetectiontask})
    \item[\texttt observation\_characterization] Determines characterization time and status (see \S\ref{sec:observationcharacterizationtask})
    \item[\texttt calc\_signal\_noise] Calculates the signal and noise fluxes for a given time interval (see \S\ref{sec:calcsignalnoisetask}) - called by \verb+observation_detection+ and \verb+observation_characterization+
    \item[\texttt update\_occulter\_mass] Updates the occulter wet mass in the Observatory module, and stores all the occulter related values in the DRM array (see \S\ref{sec:updateoccultermasstask}) - called by \verb+run_sim+
    \item[\texttt reset\_sim] Performs a full reset of the simulation (see \S\ref{sec:resetsimtask})
    \item[\texttt genOutSpec] Joins outspec dicts from all modules into one output dict (see \S\ref{sec:genOutSpectask})
    \item[\texttt generateHashName] Generates a hashname for cached files tied to this json script (see \S\ref{sec:generateHashfNametask})
    \item[\texttt revisitFilter] Filters a list of target stars by revisits (see \S\ref{sec:revisitFiltertask}) - called by \verb+next_target+
\end{itemize}

% \begin{figure}[ht]
%     \begin{center}
%         \begin{tabular}{c}
%             \includegraphics[width=\textwidth]{SurveySimulation}
%         \end{tabular}
%     \end{center}
%     \caption{\label{fig:surveysimulationmodule} Depiction of Survey Simulation module method including input, output, and updated attributes (see \S\ref{sec:runsimtask}, \S\ref{sec:nexttargettask}, \S\ref{sec:observationdetectiontask}, \S\ref{sec:observationcharacterizationtask}, \S\ref{sec:calcsignalnoisetask} and \S\ref{sec:updateoccultermasstask}).}
% \end{figure}

\subsubsection{Survey Simulation Object Attribute Initialization}

\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[scriptfile (string)] \hfill \\ JSON script file.  If not set, assumes that dictionary has been passed through specs.
    \item[nt\_flux (integer)] \hfill \\ Observation time sampling, to determine the integration time interval. Default value is 1.
    \item[nVisitsMax (integer)] \hfill \\ Maximum number of observations (in detection mode) per star. Default value is 5.
    \item[charMargin (float)] \hfill \\ Integration time margin for characterization. Default value is 0.15.
    \item[seed (integer)] \hfill \\ Random seed used to make all random number generation reproducible.
    \item[WAint (float)] \hfill \\ Working angle used for integration time calculation in units of $arcsec$.
    \item[dMagint (float)] \hfill \\ Delta magnitude used for integration time calculation.
    \item[cachedir (float)] \hfill \\ Path to desired cache directory (default will be \texttt{\$HOME/.EXOSIMS/cache}).
\end{description}
\end{itemize}

\subsubsection*{Attributes}
\begin{itemize}
\item
\begin{description}
    \item[StarCatalog (StarCatalog module)]\hfill \\ StarCatalog class object (only retained if keepStarCatalog is True, see \ref{sec:starcatalog})
    \item[PlanetPopulation (PlanetPopulation module)] \hfill \\ PlanetPopulation class object (see \ref{sec:planetpopulation})
    \item[PlanetPhysicalModel (PlanetPhysicalModel module)] \hfill \\ PlanetPhysicalModel class object (see \ref{sec:planetphysicalmodel})
    \item[OpticalSystem (OpticalSystem module)] \hfill \\ OpticalSystem class object (see \ref{sec:opticalsystem})
    \item[ZodiacalLight (ZodiacalLight module)] \hfill \\ ZodiacalLight class object (see \ref{sec:zodiacallight})
    \item[BackgroundSources (BackgroundSources module)] \hfill \\ BackgroundSources class object (see \ref{sec:backgroundsources})
    \item[PostProcessing (PostProcessing module)] \hfill \\ PostProcessing class object (see \ref{sec:postprocessing})
    \item[Completeness (Completeness module)] \hfill \\ Completeness class object (see \ref{sec:completeness})
    \item[TargetList (TargetList module)] \hfill \\ TargetList class object (see \ref{sec:targetlist})
    \item[SimulatedUniverse (SimulatedUniverse module)] \hfill \\ SimulatedUniverse class object (see \ref{sec:simulateduniverse})
    \item[Observatory (Observatory module)] \hfill \\ Observatory class object (see \ref{sec:observatory})
    \item[TimeKeeping (TimeKeeping module)] \hfill \\ TimeKeeping class object (see \ref{sec:timekeeping})
    \item[fullSpectra (boolean ndarray)] \hfill \\ Indicates if planet spectra have been captured
    \item[partialSpectra (boolean ndarray)] \hfill \\ Indicates if planet partial spectra have been captured
    \item[propagTimes (astropy Quantity array)] \hfill \\ Contains the last time the stellar system was propagated in units of $day$
    \item[lastObsTimes (astropy Quantity array)] \hfill \\ Contains the last observation start time for future completeness update in units of $day$
    \item[starVisits (integer ndarray)] \hfill \\ Contains the number of times each target was visited
    \item[starRevisit (float n$\times$2 ndarray)] \hfill \\ Contains indices of targets to revisit and revisit times of these targets in units of $day$
    \item[lastDetected (float n$\times$4 ndarray)] \hfill \\ For each target, contains 4 lists with planets' detected status, exozodi brightness (in units of $1/arcsec^2$), delta magnitude, and working angles (in units of $arcsec$)
    \item[DRM (list of dicts)] \hfill \\ Design Reference Mission, contains the results of a survey simulation
    \item[nt\_flux (integer)] \hfill \\ Observation time sampling, to determine the integration time interval
    \item[nVisitsMax (integer)] \hfill \\ Maximum number of observations (in detection mode) per star
    \item[charMargin (float)] \hfill \\ Integration time margin for characterization
    \item[seed (integer)] \hfill \\ Random seed used to make all random number generation reproducible
    \item[WAint (astropy Quantity array)] \hfill \\ Working angle used for integration time calculation in units of $arcsec$
    \item[dMagint (float ndarray)] \hfill \\ Delta magnitude used for integration time calculation
    \item[valfZmin (astropy Quantity array)] \hfill \\ value of minimum zodiacal light with units 1/arcsec$^2$
    \item[absTimefZmin (astropy Time array)] \hfill \\ absolute time in MJD and tai that minimum zodiacal light will occur next
    \item[cachedir (string)] \hfill \\ Path to cache directory
\end{description}
\end{itemize}

\subsubsection{run\_sim Method} \label{sec:runsimtask}
The \verb+run_sim+ method uses the inherited modules to generate a survey simulation, without any explicit inputs and outputs. It updates module attributes and populates the results in \verb+SurveySimulation.DRM+.
\subsubsection*{Updated Module Attributes}
\begin{itemize}
\item 
\begin{description}
    \item[SurveySimulation.DRM] \hfill \\ Python list where each entry contains a dictionary of survey simulation results for each observation.  The dictionary may include the following \verb+key:value+ pairs (from the prototype):
    \begin{description}
        \item[star\_ind (integer)] \hfill \\ Index of the observed target star
        \item[star\_name (string)] \hfill \\ Name of the observed target star
        \item[arrival\_time (float)] \hfill \\ Elapsed time since mission start when observation begins in units of $day$
        \item[OB\_nb (integer)] \hfill \\ Number/index of the observing block
        \item[plan\_inds (integer ndarray)] \hfill \\ Indices of planets orbiting the observed target star
        \item[det\_mode (dict)] \hfill \\ Observing mode selected for detection
        \item[det\_time (astropy Quantity)] \hfill \\ Integration time for detection in units of $ day $
        \item[det\_status (integer ndarray)] \hfill \\ List of detection status for each planet orbiting the observed target star, where 1 is detection, 0 missed detection, -1 below IWA, and -2 beyond OWA
        \item[det\_SNR (float ndarray)] \hfill \\ List of detection SNR values for each planet orbiting the observed target star. Non-observable planets have their SNR set to 0.
        \item[det\_fZ] (astropy Quantity)] \hfill \\ Zodiacal surface brightnesses at detection in units of $1/arcsec^2$
        \item[det\_params (dict)] \hfill \\ Dictionary of system params at detection for each planet orbiting the observed target star, including d ($AU$), phi, fEZ ($1/arcsec2$), dMag, and WA ($arcsec$)
        \item[char\_mode (dict)] \hfill \\ Observing mode selected for characterization
        \item[char\_time (astropy Quantity)] \hfill \\ Integration time for characterization in units of $ day $
        \item[char\_status (integer ndarray)] \hfill \\ List of characterization status for each planet orbiting the observed target star, where 1 is full spectrum, -1 partial spectrum, and 0 not characterized
        \item[char\_SNR (float ndarray)] \hfill \\ List of characterization SNR values for each planet orbiting the observed target star. Non-observable planets have their SNR set to 0.
        \item[char\_fZ] (astropy Quantity)] \hfill \\ Zodiacal surface brightnesses at characterization in units of $1/arcsec^2$
        \item[char\_params (dict)] \hfill \\ Dictionary of system params at characterization for each planet orbiting the observed target star, including d ($AU$), phi, fEZ ($1/arcsec2$), dMag, and WA ($arcsec$)
        \item[FA\_det\_status (integer)] \hfill \\ Detection status for a false alarm signal (1 is a false alarm, 0 is not)
        \item[FA\_char\_status (integer ndarray)] \hfill \\ (if false alarm) Characterization status for a false alarm signal, where 1 is full spectrum, -1 partial spectrum, and 0 not characterized
        \item[FA\_char\_SNR (float ndarray)] \hfill \\ (if false alarm) Characterization SNR value for a false alarm signal
        \item[FA\_char\_fEZ (astropy Quantity)] \hfill \\ (if false alarm) Exo-zodi surface brightness for a false alarm signal in units of $1/arcsec^2$
        \item[FA\_char\_dMag (float)] \hfill \\ (if false alarm) Delta magnitude for a false alarm signal
        \item[FA\_char\_WA (astropy Quantity)] \hfill \\ (if false alarm) Working angle for a false alarm signal in units of $arcsec$
        \item[slew\_time (astropy Quantity)] \hfill \\ (if occulter) Slew time to next target in units of $ day $
        \item[slew\_angle (astropy Quantity)] \hfill \\ (if occulter) Slew angle to next target in units of $ deg $
        \item[slew\_dV (astropy Quantity)] \hfill \\ (if occulter) Slew $\Delta$V in units of $ m/s $
        \item[slew\_mass\_used (astropy Quantity)] \hfill \\ (if occulter) Slew fuel mass used in units of $ kg $
        \item[sc\_mass (float)] \hfill \\ (if occulter) Maneuvering spacecraft mass at the end of target observation in units of $kg$
        \item[slew\_mass (float)] \hfill \\ (if occulter and twotanks) Slew fuel tank mass at the end of target observation in units of $kg$.
        \item[sk\_mass (float)] \hfill \\ (if occulter and twotanks) Station keeping fuel tank mass at end of target observation in units of $kg$.
        \item[det\_dV (astropy Quantity)] \hfill \\ (if occulter) Detection station-keeping $\Delta$V in units of $ m/s $
        \item[det\_mass\_used (astropy Quantity)] \hfill \\ (if occulter) Detection station-keeping fuel mass used in units of $ kg $
        \item[det\_dF\_lateral (astropy Quantity)] \hfill \\ (if occulter) Detection station-keeping lateral disturbance force on occulter in units of $ N $
        \item[det\_dF\_axial (astropy Quantity)] \hfill \\ (if occulter) Detection station-keeping axial disturbance force on occulter in units of $ N $
        \item[char\_dV (astropy Quantity)] \hfill \\ (if occulter) Characterization station-keeping $\Delta$V in units of $ m/s $
        \item[char\_mass\_used (astropy Quantity)] \hfill \\ (if occulter) Characterization station-keeping fuel mass used in units of $ kg $
        \item[char\_dF\_lateral (astropy Quantity)] \hfill \\ (if occulter) Characterization station-keeping lateral disturbance force on occulter in units of $ N $
        \item[char\_dF\_axial (astropy Quantity)] \hfill \\ (if occulter) Characterization station-keeping axial disturbance force on occulter in units of $ N $
    \end{description}
\end{description}
\end{itemize}

\subsubsection{next\_target Method} \label{sec:nexttargettask}
The \verb+next_target+ method filters target stars available by keepout, integration time, and revisits
finds index of next target star and calculates its integration time. This method chooses the next target star index based on which stars are available, their integration time, and maximum completeness. Also updates DRM. Returns None if no target could be found.
\subsubsection*{Input}
\begin{itemize}
\item 
\begin{description}
    \item[old\_sInd (integer)] \hfill \\ Index of the previous target star (set to None for the first observation)
    \item[mode (dict)] \hfill \\ Selected observing mode (from OpticalSystem)
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[DRM (dict)] \hfill \\ Dictionary containing survey simulation results
    \item[sInd (integer)] \hfill \\ Index of next target star. Defaults to None.
    \item[det\_intTime (astropy Quantity)] \hfill \\ Selected star integration time for detection in units of $day$. Defaults to None.
\end{description}
\end{itemize}

% \subsubsection{intTimeFilter} \label{sec:intTimeFiltertask}
% The intTimeFilter method is a helper method for next target to filter out target stars by their integration times.
% \subsubsection*{Input}
% \begin{itemize}
% \item 
% \begin{description}
%     \item[sInds (integer array)] \hfill \\ Indices of target stars to filter
%     \item[startTimes (astropy Quantity array)] \hfill \\ absolute start times of observations. must be same size as sInds
%     \item[mode (dict)] \hfill \\ Selected observing mode (from OpticalSystem)
%     \item[startTimesNorm (astropy Quantity array)] \hfill \\ The observation starting times normalized
%     \item[intTimes (astropy Quantity array)] \hfill \\ Integration times for detection in units of day
% \end{description}
% \end{itemize}
% \subsubsection*{Output}
% \begin{itemize}
% \item 
% \begin{description}
%     \item[sInds (integer array)] \hfill \\ Indices of filtered stars
%     \item[intTimes (astropy Quantity array)] \hfill \\ Integration times for detection of filtered stars in units of day
%     \item[startTimesNorm (astropy Quantity array)] \hfill \\ The observation starting times normalized
% \end{description}
% \end{itemize}

\subsubsection{calc\_targ\_intTime Method} \label{sec:calcTargIntTimetask}
The calc\_targ\_intTime method is a helper method for next\_target to aid in overloading for alternative implementations.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[sInds (integer array)] \hfill \\ Indicies of available targets
    \item[startTimes (astropy Quantity array)] \hfill \\ absolute start times of observations. must be the same size as sInds
    \item[mode (dict)] \hfill \\ Selected observing mode for detection (from OpticalSystem)
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[intTimes (integer array)] \hfill \\ Integration times for detection same dimension as sInds
\end{description}
\end{itemize}

\subsubsection{choose\_next\_target Method} \label{sec:chooseNextTargettask}
Helper method for method next\_target to simplify alternative implementation.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[old\_sInd (integer)] \hfill \\ Index of previous target star
    \item[sInds (integer array)] \hfill \\ Indices of available targets
    \item[slewTimes (astropy quantity array)] \hfill \\ slew times to all stars (must be indexed by sInds)
    \item[intTimes (astropy Quantity array)] \hfill \\ Integration times for detection in units of day
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[sInd (integer)] \hfill \\ Index of next target star
\end{description}
\end{itemize}

\subsubsection{observation\_detection Method} \label{sec:observationdetectiontask}
The \verb+observation_detection+ method determines the detection status and updates the last detected list and the revisit list. 
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[sInd (integer)] \hfill \\ Integer index of the star of interest
    \item[intTime (astropy Quantity)] \hfill \\ Selected star integration time in units of $day$. Defaults to None.
    \item[mode (dict)] \hfill \\ Selected observing mode (from OpticalSystem)
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item[detected (integer ndarray)] \hfill \\ Detection status for each planet orbiting the observed target star, where 1 is detection, 0 missed detection, -1 below IWA, and -2 beyond OWA
    \item[fZ (astropy Quantity)] \hfill \\ Zodiacal surface brightnesses at detection in units of $1/arcsec^2$
    \item[systemParams (dict)] \hfill \\ Dictionary of time-dependant planet properties averaged over the duration of the integration
    \item[SNR (float ndarray)] \hfill \\ Detection signal-to-noise ratio of the observable planets
    \item[FA (boolean)] \hfill \\ False alarm (false positive) boolean
\end{description}
\end{itemize}

\subsubsection{scheduleRevisit Method} \label{sec:scheduleRevisittask}
A Helper Method for scheduling revisits after observation detection
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[sInd (integer)] \hfill \\ index of the star just detected
    \item[smin (AU)] \hfill \\ minimum separation of the planet to star of planet just detected
    \item[pInds (astropy Quantity array)] \hfill \\ Indices of planets around target star
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item 
\begin{description}
    \item updates starRevisit Attribute
\end{description}
\end{itemize}

\subsubsection{observation\_characterization Method} \label{sec:observationcharacterizationtask}
The \verb+observation_characterization+ method finds if characterizations are possible and relevant information.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[sInd (integer)] \hfill \\ Integer index of the star of interest
    \item[mode (dict)] \hfill \\ Selected observing mode (from OpticalSystem)
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[characterized (integer ndarray)] \hfill \\ Characterization status for each planet orbiting the observed target star including False Alarm if any, where 1 is full spectrum, -1 partial spectrum, and 0 not characterized
    \item[fZ (astropy Quantity)] \hfill \\ Zodiacal surface brightnesses at characterization in units of $1/arcsec^2$
    \item[systemParams (dict)] \hfill \\ Dictionary of time-dependant planet properties averaged over the duration of the integration
    \item[SNR (float ndarray)] \hfill \\ Characterization signal-to-noise ratio of the observable planets
    \item[char\_intTime (astropy Quantity)] \hfill \\ Selected star characterization time in units of $day$
\end{description}
\end{itemize}

\subsubsection{calc\_signal\_noise Method} \label{sec:calcsignalnoisetask}
The \verb+calc_signal_noise+ method calculates the signal and noise fluxes for a given time interval.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[sInd (integer)] \hfill \\ Integer index of the star of interest
    \item[pInds (integer)] \hfill \\ Integer indices of the planets of interest
    \item[t\_int (astropy Quantity)] \hfill \\ Integration time interval interval in units of $day$
    \item[mode (dict)] \hfill \\ Selected observing mode (from OpticalSystem)
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[Signal (float)] \hfill \\ Counts of signal
    \item[Noise (float)] \hfill \\ Counts of background noise variance
\end{description}
\end{itemize}

\subsubsection{update\_occulter\_mass Method} \label{sec:updateoccultermasstask}
The \verb+update_occulter_mass+ method updates the occulter wet mass in the Observatory module, and stores all the occulter related values in the DRM array. 
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[DRM (dicts)] \hfill \\ Contains the results of survey simulation
    \item[sInd (integer)] \hfill \\ Integer index of the star of interest
    \item[t\_int (astropy Quantity)] \hfill \\ Selected star integration time (for detection or characterization) in units of $day$
    \item[skMode (string)] \hfill \\ Station keeping observing mode type
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[DRM (dicts)] \hfill \\ Contains the results of survey simulation
\end{description}
\end{itemize}

\subsubsection{reset\_sim Method} \label{sec:resetsimtask}
Performs a full reset of the current simulation:
\begin{enumerate}
    \item  Re-initializes the TimeKeeping object with its own outspec (i.e., \verb+TimeKeeping._outspec+ is passed directly to the TimeKeeping constructor)
    \item  If genNewPlanets is True (default) generates all new planets based on the original input specification. If genNewPlanets is False, then the original planets will remain. Setting to True forces rewindPlanets to be True as well.
    \item  If rewindPlanets is True (default), then the current set of planets will be reset to their original orbital phases. If both genNewPlanets and rewindPlanet are False, the original planets will be retained and will not be rewound to their initial starting locations (i.e., all systems will remain at the times they were at the end of the last run, thereby effectively randomizing planet phases).
    \item If seed is None (default) Re-initializes the SurveySimulation object, including resetting the DRM to [] and the random seed will be reset. If seed is specified, the seed will be set to the specified seed.
\end{enumerate}

\subsubsection{genOutSpec Method} \label{sec:genOutSpectask}
Join all \_outspec dicts from all modules into one output dict and optionally write out to JSON file on disk.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[tofile (string)] \hfill \\ Name of the file containing all output specifications (outspecs). Default to None.
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[out (dictionary)] \hfill \\ Dictionary containing additional user specification values and desired module names.
\end{description}
\end{itemize}

\subsubsection{generateHashfName Method} \label{sec:generateHashfNametask}
Generate cached file Hashname
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[specs] \hfill \\ The json script elements of the simulation to be run
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[cachefname (string)] \hfill \\ a string containing the file location, hashnumber of the cache name based off of the completeness to be computed (completeness specs if available else standard module)
\end{description}
\end{itemize}

\subsubsection{revisitFilter Method} \label{sec:revisitFiltertask}
Helper method for overloading revisit filtering in next\_target
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[sInds [sInds]] \hfill \\ indices of stars still in observation list
    \item[tmpCurrentTimeNorm (MJD)] \hfill \\ the simulation time after overhead was added in MJD form
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[sInds [sInds] (integer array)] \hfill \\ indces of the stars still in observation list
\end{description}
\end{itemize}

%% Proposed Changes 6/28 - Gabe
\subsubsection{refineOcculterSlews Method} \label{sec:refineOcculterSlewstask}
Refines the selection of occulter slew times by filtering based on mission time constraints and selecting the best slew time for each star. This method calls on other occulter methods within SurveySimulation depending on how slew times were calculated prior to calling this function (i.e. depending on which implementation of the Observatory module is used). 
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[old\_sInd (integer)] \hfill \\ Integer index of the most recently observed star
    \item[sInds [sInds]] \hfill \\ indices of stars still in observation list
    \item[slewTimes (astropy quantity array)] \hfill \\ slew times to all stars (must be indexed by sInds)
    \item[observableTimes (astropy Time list)] \hfill \\ A binary array with TargetList.nStars rows and (missionFinishAbs-missionStart)/dt columns where dt is 1 day by default. A value of 1 indicates the star is in keepout for (and therefore cannot be observed). A value of 0 indicates the star is not in keepout and may be observed.
    \item[sd (astropy Quantity)] \hfill \\ Angular separation between stars in rad
    \item[tmpCurrentTimeNorm (MJD)] \hfill \\ the simulation time after overhead was added in MJD form
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[sInds [sInds] (integer array)] \hfill \\ indces of the stars still in observation list
    \item[slewTimes (astropy quantity array)] \hfill \\ slew times to all stars (must be indexed by sInds)
    \item[intTimes (astropy Quantity array)] \hfill \\ Integration times for detection in units of day
    \item[dV (astropy Quantity)] \hfill \\ Delta-V used to transfer to new star line of sight in units of m/s
    
\end{description}
\end{itemize}

\subsubsection{filterOcculterSlews Method} \label{sec:filterOcculterSlewstask}
Used by the refineOcculterSlews method when slew times have been selected a priori. This method filters out slews that are not within desired observing blocks, the maximum allowed integration time, and are within future keepouts.
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[old\_sInd (integer)] \hfill \\ Integer index of the most recently observed star
    \item[sInds [sInds]] \hfill \\ indices of stars still in observation list
    \item[slewTimes (astropy quantity array)] \hfill \\ slew times to all stars (must be indexed by sInds)
    \item[observableTimes (astropy Time list)] \hfill \\ A binary array with TargetList.nStars rows and (missionFinishAbs-missionStart)/dt columns where dt is 1 day by default. A value of 1 indicates the star is in keepout for (and therefore cannot be observed). A value of 0 indicates the star is not in keepout and may be observed.
    \item[tmpCurrentTimeNorm (MJD)] \hfill \\ the simulation time after overhead was added in MJD form
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[sInds [sInds] (integer array)] \hfill \\ indces of the stars still in observation list
    \item[slewTimes (astropy quantity array)] \hfill \\ slew times to all stars (must be indexed by sInds)
    \item[intTimes (astropy Quantity array)] \hfill \\ Integration times for detection in units of day
    \item[dV (astropy Quantity)] \hfill \\ Delta-V used to transfer to new star line of sight in units of m/s
    
\end{description}
\end{itemize}

\subsubsection{findAllowableOcculterSlews Method} \label{sec:findAllowableOcculterSlewstask}
Used by the refineOcculterSlews method when slew times have not been selected, allowing an exploration of that parameter. This method returns an array of possible slew times for each star in which all are within desired observing blocks, allow integration times, and the stars remain outside of keepout throughout integration. 
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[old\_sInd (integer)] \hfill \\ Integer index of the most recently observed star
    \item[sInds [sInds]] \hfill \\ indices of stars still in observation list
    \item[slewTimes (astropy quantity array)] \hfill \\ slew times to all stars (must be indexed by sInds)
    \item[observableTimes (astropy Time list)] \hfill \\ A binary array with TargetList.nStars rows and (missionFinishAbs-missionStart)/dt columns where dt is 1 day by default. A value of 1 indicates the star is in keepout for (and therefore cannot be observed). A value of 0 indicates the star is not in keepout and may be observed.
    \item[tmpCurrentTimeNorm (MJD)] \hfill \\ the simulation time after overhead was added in MJD form
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[sInds [sInds] (integer array)] \hfill \\ indces of the stars still in observation list
    \item[slewTimesRange (astropy quantity array)] \hfill \\ slew times to all stars (must be indexed by sInds)
    \item[intTimesRange (astropy Quantity array)] \hfill \\ Integration times for detection in units of day
    
\end{description}
\end{itemize}


\subsubsection{selectOcculterSlews Method} \label{sec:selectOcculterSlewstask}
After finding a range of allowable slew times, this method selects the best slew time for each star based on desired criteria. Slew times for the default method are selected which allow the maximum possible amount of characterization time for each star should there be a detection. 

\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[old\_sInd (integer)] \hfill \\ Integer index of the most recently observed star
    \item[sInds [sInds]] \hfill \\ indices of stars still in observation list
    \item[slewTimesRange (astropy quantity array)] \hfill \\ slew times to all stars (must be indexed by sInds)
    \item[intTimesRange (astropy Quantity array)] \hfill \\ Integration times for detection in units of day
    \item[observableTimes (astropy Time list)] \hfill \\ A binary array with TargetList.nStars rows and (missionFinishAbs-missionStart)/dt columns where dt is 1 day by default. A value of 1 indicates the star is in keepout for (and therefore cannot be observed). A value of 0 indicates the star is not in keepout and may be observed.
    \item[sd (astropy Quantity)] \hfill \\ Angular separation between stars in rad
    \item[tmpCurrentTimeNorm (MJD)] \hfill \\ the simulation time after overhead was added in MJD form
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[sInds [sInds] (integer array)] \hfill \\ indces of the stars still in observation list
    \item[slewTimes (astropy quantity array)] \hfill \\ slew times to all stars (must be indexed by sInds)
    \item[intTimes (astropy Quantity array)] \hfill \\ Integration times for detection in units of day
    \item[dV (astropy Quantity)] \hfill \\ Delta-V used to transfer to new star line of sight in units of m/s
    
\end{description}
\end{itemize}

% SURVEY ENSEMBLE NEEDS UPDATING

\subsection{Survey Ensemble}
The Survey Ensemble module's only task is to run multiple simulations.  While the implementation of this module is not at all dependent on a particular mission design, it can vary to take advantage of available parallel-processing resources.  As the generation of a survey ensemble is an embarrassingly parallel task---every survey simulation is fully independent and can be run as a completely separate process---significant gains in execution time can be achieved with parallelization.  The baseline implementation of this module contains a simple looping function that executes the desired number of simulations sequentially, as well as a locally parallelized version based on IPython Parallel.

Depending on the local setup, the Survey Ensemble implementation can save significant time by cloning survey module objects and reinitializing only those sub-modules that have stochastic elements (i.e., the simulated universe). This is currently achieved with the \verb+reset_sim+ method in SurveySimulation.

Another possible implementation variation is to use the Survey Ensemble module to conduct investigations of the effects of varying any normally static parameter.  This could be done, for example, to explore the impact on yield in cases where the non-coronagraph system throughput, or elements of the propulsion system, are mischaracterized prior to launch.  This SE module implementation would overwrite the parameter of interest given in the input specification for every individual survey executed, and saving the true value of the parameter used along with the simulation output.

The parallel implementation in the Prototype is geared towards an ipyparallel-based parallelization scheme, where a single method is asynchronously mapped to $n$ workers.  The method is called \verb+run_one+ and takes as inputs two keyword parameters:

\begin{itemize}
\item 
\begin{description}
    \item[genNewPlanets (bool)] \hfill \\ Generate new planets for every run (defaults true).
    \item[rewindPlanets (bool)] \hfill \\ Reset all planets to their initial conditions on each sim (defaults True, is ignored if genNewPlanets is True).
\end{description}
\end{itemize}

\subsubsection{run\_ensemble Method} 
\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[sim (MissionSim object)] \hfill \\ EXOSIMS.MissionSim.MissionSim object
    \item[nb\_run\_sim (integer)] \hfill \\ number of simulations to run
    \item[run\_one (method)] \hfill \\ method to call for each simulation
    \item[genNewPlanets (boolean)] \hfill \\ flag indicating whether to generate new planets each simulation (True means new planets will be generated)
    \item[rewindPlanets (boolean)] \hfill \\ flag indicating whether planets will be rewound (True means planets will be rewound)
    \item[kwargs ()] \hfill \\
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[res (list dict)] \hfill \\ simulation list of dictionaries
\end{description}
\end{itemize}

\subsubsection{run\_one Method} 

\subsubsection*{Input}
\begin{itemize}
\item
\begin{description}
    \item[SS (Survey Simulation Object)] \hfill \\ SurveySimulation object
    \item[genNewPlanets (boolean)] \hfill \\ flag indicating whether to rewind planets in reset\_sim function call (True means rewind) (default is True)
    \item[rewindPlanets (boolean)] \hfill \\ flag indicating whether to generate new plants in reset\_sim function  call (True means rewind) (default is True)
\end{description}
\end{itemize}
\subsubsection*{Output}
\begin{itemize}
\item
\begin{description}
    \item[res (list dict)] \hfill \\ simulation list of dictionaries
\end{description}
\end{itemize}

\section*{Acknowledgements}  EXOSIMS development is supported by NASA Grant Nos. NNX14AD99G (GSFC) and NNX15AJ67G (WPS).


\end{document}
